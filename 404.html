<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>lulzx</title>
<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
<script src="https://unpkg.com/vue-router@4/dist/vue-router.global.js"></script>
<style>
:root {
    --gray-subtle: #e5e5e5;
    --gray-mid: #999;
    --gray-light: #f5f5f5;
    --bg: #fff;
    --text: #000;
    --border: #000;
    --bg-inverted: #000;
    --text-inverted: #fff;
    --selection-bg: #000;
    --selection-text: #fff;
}
body.dark {
    --gray-subtle: #333;
    --gray-mid: #888;
    --gray-light: #1a1a1a;
    --bg: #111;
    --text: #e5e5e5;
    --border: #e5e5e5;
    --bg-inverted: #e5e5e5;
    --text-inverted: #111;
    --selection-bg: #e5e5e5;
    --selection-text: #111;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

::selection {
    background: var(--selection-bg);
    color: var(--selection-text);
}

html {
    font-size: 16px;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    background: var(--bg);
    color: var(--text);
    line-height: 1.6;
    height: 100vh;
    overflow: hidden;
}

#app {
    height: 100%;
    overflow: auto;
}

.container {
    height: calc(100vh - 2rem);
    display: flex;
    flex-direction: column;
    border: 2px solid var(--border);
    margin: 1rem;
    overflow: hidden;
}

.main {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 4rem 6rem;
    border-bottom: 2px solid var(--border);
}

.statement {
    font-size: clamp(1.5rem, 4vw, 3.5rem);
    font-weight: 500;
    max-width: 1200px;
    letter-spacing: -0.03em;
    line-height: 1.45;
    text-wrap: balance;
}

.word {
    display: inline-block;
    cursor: pointer;
    padding: 0 0.1em;
    margin: 0 -0.1em;
    border-radius: 0;
    transition: all 0.15s ease;
    text-decoration: none;
    color: inherit;
    text-decoration-line: underline;
    text-decoration-color: var(--gray-subtle);
    text-underline-offset: 3px;
    text-decoration-thickness: 1px;
}

.word:hover {
    background: var(--text);
    color: var(--bg);
    text-decoration: none;
    transform: scale(1.02);
}

.punctuation {
    display: inline;
}

.footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem 2rem;
    font-size: 0.875rem;
    border-top: 2px solid var(--border);
}

.footer a {
    color: var(--text);
    text-decoration: underline;
    text-underline-offset: 2px;
}

.footer a:hover {
    background: var(--text);
    color: var(--bg);
    text-decoration: none;
}

.footer-links {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
}

/* Word Page Styles */
.word-page {
    border: 2px solid var(--border);
    margin: 1rem;
    display: flex;
    flex-direction: column;
    min-height: calc(100vh - 2rem);
    animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

@keyframes blockIn {
    from { opacity: 0; transform: translateY(16px); }
    to { opacity: 1; transform: translateY(0); }
}

.word-header {
    padding: 1.5rem 2rem;
    border-bottom: 2px solid var(--border);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.word-header-left {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.breadcrumbs {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.8rem;
    color: var(--gray-mid);
}

.breadcrumbs a {
    color: var(--gray-mid);
    text-decoration: none;
}

.breadcrumbs a:hover {
    color: var(--text);
}

.breadcrumbs .sep {
    font-size: 0.7rem;
}

.back {
    color: var(--text);
    text-decoration: none;
    font-size: 0.875rem;
}

.back:hover {
    background: var(--text);
    color: var(--bg);
}

.word-title-section {
    padding: 3rem 4rem;
    border-bottom: 2px solid var(--border);
    display: flex;
    align-items: baseline;
    gap: 1.5rem;
    flex-wrap: wrap;
}

.word-title {
    font-size: clamp(3rem, 10vw, 8rem);
    font-weight: 700;
    letter-spacing: -0.04em;
    line-height: 1;
}

.stage-badge {
    display: inline-block;
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.12em;
    padding: 0.25rem 0.75rem;
    vertical-align: middle;
}

.stage-seed {
    border: 1px dashed var(--border);
}

.stage-sprout {
    border: 2px solid var(--border);
}

.stage-evergreen {
    border: 4px double var(--border);
}

.word-meta {
    font-size: 0.8rem;
    color: var(--gray-mid);
    padding: 0.75rem 4rem;
    border-bottom: 1px solid var(--gray-subtle);
    display: flex;
    gap: 2rem;
}

.word-content {
    flex: 1;
    padding: 3rem 4rem;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 2rem;
    align-content: start;
}

.block {
    border: 2px solid var(--border);
    padding: 2rem;
    transition: transform 0.4s ease, box-shadow 0.2s ease, opacity 0.4s ease;
    opacity: 0;
    transform: translateY(24px);
}

.block.revealed {
    opacity: 1;
    transform: translateY(0);
}

.block:hover {
    transform: translateY(-2px);
    box-shadow: 4px 4px 0 var(--border);
}

.block h2 {
    font-size: 0.875rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    margin-bottom: 1rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--border);
}

.block p, .block li {
    font-size: 1rem;
    line-height: 1.7;
    margin-bottom: 0.75rem;
}

.block ul {
    list-style: none;
    padding: 0;
}

.block li::before {
    content: "\2192  ";
    font-weight: 700;
}

.block a {
    color: var(--text);
    text-decoration: underline;
}

.block a:hover {
    background: var(--text);
    color: var(--bg);
}

.block-inverted {
    background: var(--bg-inverted);
    color: var(--text-inverted);
    border-color: var(--bg-inverted);
}

.block-inverted h2 {
    border-bottom-color: var(--text-inverted);
}

.block-inverted a {
    color: var(--text-inverted);
}

.block-inverted a:hover {
    background: var(--text-inverted);
    color: var(--bg-inverted);
}

.stat {
    font-size: 4rem;
    font-weight: 700;
    margin-bottom: 0.5rem;
}

.stat-label {
    font-size: 0.875rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
}

.zero {
    font-size: 8rem;
    font-weight: 900;
    line-height: 1;
}

.block-zero {
    grid-column: 1 / -1;
}

code {
    font-family: "Courier New", monospace;
    background: var(--gray-light);
    padding: 0.2em 0.4em;
    font-size: 0.9em;
}

/* Connections Section */
.connections-section,
.notes-section {
    padding: 2rem 4rem;
    border-top: 2px solid var(--border);
}

.section-title {
    font-size: 0.875rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    margin-bottom: 1.25rem;
}

.chips {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
}

.chip {
    display: inline-block;
    padding: 0.4rem 1rem;
    border: 2px solid var(--border);
    text-decoration: none;
    color: var(--text);
    font-size: 0.875rem;
    transition: all 0.15s ease;
    letter-spacing: -0.01em;
}

.chip:hover {
    background: var(--text);
    color: var(--bg);
    transform: translateY(-2px);
    box-shadow: 2px 2px 0 var(--border);
}

.note-link {
    display: block;
    padding: 1rem 1.5rem;
    border: 2px solid var(--border);
    text-decoration: none;
    color: var(--text);
    margin-bottom: 0.5rem;
    transition: all 0.15s ease;
    font-size: 0.95rem;
}

.note-link:hover {
    transform: translateX(4px);
    box-shadow: 2px 2px 0 var(--border);
}

.note-link .note-link-title {
    font-weight: 600;
}

.note-link .note-link-stage {
    font-size: 0.75rem;
    color: var(--gray-mid);
    text-transform: uppercase;
    letter-spacing: 0.08em;
    margin-left: 0.75rem;
}

.wander-section {
    padding: 1.5rem 4rem;
    border-top: 2px solid var(--border);
    display: flex;
    justify-content: space-between;
}

.wander-btn {
    color: var(--text);
    text-decoration: none;
    font-size: 0.875rem;
    text-decoration: underline;
    text-decoration-style: dashed;
    text-underline-offset: 3px;
    padding: 0.25rem 0.5rem;
    transition: all 0.15s ease;
    cursor: pointer;
    background: none;
    border: none;
    font-family: inherit;
}

.wander-btn:hover {
    background: var(--text);
    color: var(--bg);
    text-decoration: none;
}

/* Inline word link */
.inline-word-link {
    color: var(--text);
    text-decoration: underline;
    text-decoration-color: var(--gray-subtle);
    text-underline-offset: 2px;
    text-decoration-thickness: 1px;
    transition: all 0.1s ease;
}

.inline-word-link:hover {
    background: var(--text);
    color: var(--bg);
    text-decoration: none;
}

/* Note Page Styles */
.note-page {
    border: 2px solid var(--border);
    margin: 1rem;
    display: flex;
    flex-direction: column;
    min-height: calc(100vh - 2rem);
    animation: fadeIn 0.3s ease;
}

.note-header {
    padding: 3rem 4rem;
    border-bottom: 2px solid var(--border);
}

.note-title {
    font-size: clamp(2rem, 5vw, 3.5rem);
    font-weight: 700;
    letter-spacing: -0.03em;
    line-height: 1.15;
    margin-bottom: 1rem;
}

.note-meta {
    font-size: 0.8rem;
    color: var(--gray-mid);
    display: flex;
    gap: 2rem;
    align-items: center;
}

.note-body {
    padding: 3rem 4rem;
    max-width: 760px;
    font-size: 1.05rem;
    line-height: 1.8;
    border-bottom: 2px solid var(--border);
}

.note-body p {
    margin-bottom: 1.5rem;
}

.note-body h2 {
    font-size: 1.25rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-top: 3rem;
    margin-bottom: 1rem;
    padding-bottom: 0.75rem;
    border-bottom: 1px solid var(--border);
}

.note-body ul, .note-body ol {
    margin-bottom: 1.5rem;
    padding-left: 1.5rem;
}

.note-body li {
    margin-bottom: 0.5rem;
}

.note-body blockquote {
    border-left: 4px solid var(--border);
    padding-left: 1.5rem;
    margin: 2rem 0;
    font-style: italic;
    color: var(--gray-mid);
    font-size: 1.1rem;
}

.note-body strong {
    font-weight: 700;
}

.note-body pre {
    background: var(--bg-inverted);
    color: var(--text-inverted);
    padding: 1.5rem;
    margin: 1.5rem 0;
    overflow-x: auto;
    font-size: 0.9rem;
    line-height: 1.6;
    border: 2px solid var(--border);
}

.note-body pre code {
    background: none;
    color: var(--text-inverted);
    padding: 0;
    font-size: inherit;
}

.note-body code {
    font-family: "Courier New", monospace;
    background: var(--gray-light);
    padding: 0.15em 0.4em;
    font-size: 0.9em;
    border: 1px solid var(--gray-subtle);
}

.note-connections {
    padding: 2rem 4rem;
    border-bottom: 2px solid var(--border);
}

.note-related {
    padding: 2rem 4rem;
    border-bottom: 2px solid var(--border);
}

/* Garden Map Styles */
.garden-page {
    border: 2px solid var(--border);
    margin: 1rem;
    display: flex;
    flex-direction: column;
    min-height: calc(100vh - 2rem);
    animation: fadeIn 0.3s ease;
}

.garden-header {
    padding: 3rem 4rem;
    border-bottom: 2px solid var(--border);
}

.garden-title {
    font-size: clamp(2.5rem, 6vw, 5rem);
    font-weight: 700;
    letter-spacing: -0.04em;
    line-height: 1;
    margin-bottom: 1rem;
}

.garden-subtitle {
    font-size: 1rem;
    color: var(--gray-mid);
    max-width: 500px;
}

.garden-filters {
    padding: 1.25rem 4rem;
    border-bottom: 2px solid var(--border);
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
}

.filter-btn {
    padding: 0.35rem 1rem;
    border: 2px solid var(--border);
    background: var(--bg);
    color: var(--text);
    font-family: inherit;
    font-size: 0.8rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    cursor: pointer;
    transition: all 0.15s ease;
}

.filter-btn:hover,
.filter-btn.active {
    background: var(--text);
    color: var(--bg);
}

.garden-section {
    padding: 2rem 4rem;
    border-bottom: 2px solid var(--border);
}

.garden-section-title {
    font-size: 0.875rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    margin-bottom: 1.5rem;
    padding-bottom: 0.75rem;
    border-bottom: 1px solid var(--border);
}

.garden-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    gap: 0.75rem;
}

.garden-card {
    border: 2px solid var(--border);
    padding: 1rem 1.25rem;
    text-decoration: none;
    color: var(--text);
    transition: transform 0.4s ease, box-shadow 0.15s ease, opacity 0.4s ease;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    opacity: 0;
    transform: translateY(24px);
}

.garden-card.revealed {
    opacity: 1;
    transform: translateY(0);
}

.garden-card:hover {
    transform: translateY(-2px);
    box-shadow: 4px 4px 0 var(--border);
}

.garden-card-name {
    font-weight: 700;
    font-size: 1.1rem;
    letter-spacing: -0.02em;
}

.garden-card-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.75rem;
    color: var(--gray-mid);
}

.stage-dot {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    vertical-align: middle;
}

.stage-dot-seed {
    border: 1px dashed var(--border);
    background: transparent;
}

.stage-dot-sprout {
    border: 1.5px solid var(--border);
    background: transparent;
}

.stage-dot-evergreen {
    background: var(--text);
}

.garden-notes-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 0.75rem;
}

.garden-note-card {
    border: 2px solid var(--border);
    padding: 1.25rem 1.5rem;
    text-decoration: none;
    color: var(--text);
    transition: transform 0.4s ease, box-shadow 0.15s ease, opacity 0.4s ease;
    opacity: 0;
    transform: translateY(24px);
}

.garden-note-card.revealed {
    opacity: 1;
    transform: translateY(0);
}

.garden-note-card:hover {
    transform: translateX(4px);
    box-shadow: 2px 2px 0 var(--border);
}

.garden-note-title {
    font-weight: 700;
    font-size: 1rem;
    margin-bottom: 0.5rem;
    letter-spacing: -0.01em;
}

.garden-note-meta {
    font-size: 0.75rem;
    color: var(--gray-mid);
    display: flex;
    gap: 1rem;
    align-items: center;
}

/* Search palette */
.search-overlay {
    position: fixed;
    inset: 0;
    background: rgba(255,255,255,0.92);
    z-index: 1000;
    display: flex;
    align-items: flex-start;
    justify-content: center;
    padding-top: 20vh;
}
body.dark .search-overlay {
    background: rgba(17,17,17,0.92);
}
.search-modal {
    width: 100%;
    max-width: 520px;
    border: 2px solid var(--border);
    background: var(--bg);
    margin: 0 1rem;
}
.search-input {
    width: 100%;
    padding: 1rem 1.25rem;
    border: none;
    border-bottom: 2px solid var(--border);
    font-family: inherit;
    font-size: 1.1rem;
    outline: none;
    background: transparent;
    color: var(--text);
}
.search-input::placeholder {
    color: var(--gray-mid);
}
.search-results {
    max-height: 320px;
    overflow-y: auto;
}
.search-result {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.75rem 1.25rem;
    cursor: pointer;
    transition: all 0.1s ease;
    text-decoration: none;
    color: var(--text);
    border-bottom: 1px solid var(--gray-subtle);
}
.search-result:last-child {
    border-bottom: none;
}
.search-result:hover,
.search-result.active {
    background: var(--text);
    color: var(--bg);
}
.search-result-type {
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    opacity: 0.6;
}
.search-hint {
    padding: 0.75rem 1.25rem;
    font-size: 0.8rem;
    color: var(--gray-mid);
    text-align: center;
}

/* Hover preview card */
.preview-card {
    position: fixed;
    z-index: 900;
    background: var(--bg);
    border: 2px solid var(--border);
    box-shadow: 4px 4px 0 var(--border);
    padding: 1rem 1.25rem;
    max-width: 280px;
    pointer-events: none;
    font-size: 0.875rem;
    line-height: 1.5;
}
.preview-card-name {
    font-weight: 700;
    font-size: 1rem;
    margin-bottom: 0.35rem;
}
.preview-card-stage {
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--gray-mid);
    margin-bottom: 0.5rem;
}
.preview-card-excerpt {
    color: var(--gray-mid);
}
@media (hover: none) {
    .preview-card { display: none !important; }
}

/* Force graph */
.graph-container {
    position: relative;
    height: 500px;
    border-bottom: 2px solid var(--border);
    cursor: default;
}
.graph-container canvas {
    width: 100%;
    height: 100%;
    display: block;
}
.graph-tooltip {
    position: absolute;
    background: var(--bg);
    border: 2px solid var(--border);
    padding: 0.4rem 0.75rem;
    font-size: 0.8rem;
    pointer-events: none;
    white-space: nowrap;
    z-index: 10;
}

/* Page transitions */
.page-enter-active,
.page-leave-active {
    transition: opacity 0.2s ease, transform 0.2s ease;
}
.page-enter-from {
    opacity: 0;
    transform: translateY(8px);
}
.page-leave-to {
    opacity: 0;
    transform: translateY(-4px);
}

/* Responsive */
@media (max-width: 800px) {
    .main {
        padding: 2.5rem 2rem;
    }
    .statement {
        font-size: clamp(1.3rem, 3.5vw, 2.5rem);
    }
    .word-title-section {
        padding: 2rem 2rem;
    }
    .word-content,
    .connections-section,
    .notes-section,
    .wander-section,
    .note-header,
    .note-body,
    .note-connections,
    .note-related,
    .garden-header,
    .garden-filters,
    .garden-section {
        padding-left: 2rem;
        padding-right: 2rem;
    }
    .word-meta {
        padding-left: 2rem;
        padding-right: 2rem;
    }
    .word-content {
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    }
    .note-body {
        padding-left: 2rem;
        padding-right: 2rem;
    }
}

@media (max-width: 500px) {
    .container {
        margin: 0.5rem;
        height: calc(100vh - 1rem);
    }
    .main {
        padding: 1.5rem;
    }
    .statement {
        font-size: clamp(1.2rem, 5vw, 2rem);
    }
    .footer {
        flex-direction: column;
        gap: 0.75rem;
        text-align: center;
        padding: 0.75rem 1rem;
    }
    .footer-links {
        justify-content: center;
    }
    .word-page,
    .note-page,
    .garden-page {
        margin: 0.5rem;
        min-height: calc(100vh - 1rem);
    }
    .word-title-section {
        padding: 1.5rem;
    }
    .word-title {
        font-size: clamp(2.5rem, 15vw, 5rem);
    }
    .word-content,
    .connections-section,
    .notes-section,
    .wander-section,
    .note-header,
    .note-body,
    .note-connections,
    .note-related,
    .garden-header,
    .garden-filters,
    .garden-section {
        padding-left: 1.5rem;
        padding-right: 1.5rem;
    }
    .word-meta {
        padding-left: 1.5rem;
        padding-right: 1.5rem;
        flex-wrap: wrap;
        gap: 0.5rem;
    }
    .word-content {
        grid-template-columns: 1fr;
        padding-top: 1.5rem;
        padding-bottom: 1.5rem;
        gap: 1rem;
    }
    .block {
        padding: 1.25rem;
    }
    .garden-grid {
        grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
    }
    .garden-notes-grid {
        grid-template-columns: 1fr;
    }
    .breadcrumbs {
        display: none;
    }
    .word-header {
        padding: 1rem 1.5rem;
    }
    .note-header {
        padding-top: 2rem;
        padding-bottom: 2rem;
    }
    .note-title {
        font-size: clamp(1.5rem, 6vw, 2.5rem);
    }
    .note-body {
        padding-top: 2rem;
        padding-bottom: 2rem;
        font-size: 1rem;
    }
    .note-meta {
        flex-wrap: wrap;
        gap: 0.5rem;
    }
    .garden-title {
        font-size: clamp(2rem, 8vw, 3rem);
    }
    .chips {
        gap: 0.35rem;
    }
    .chip {
        padding: 0.3rem 0.75rem;
        font-size: 0.8rem;
    }
    .wander-section {
        padding-top: 1rem;
        padding-bottom: 1rem;
    }
    .graph-container {
        height: 300px;
    }
}

/* Reduced motion */
@media (prefers-reduced-motion: reduce) {
    .block, .garden-card, .garden-note-card {
        opacity: 1 !important;
        transform: none !important;
        transition: none !important;
    }
    .word-page, .note-page, .garden-page, .timeline-page {
        animation: none !important;
    }
}

/* Reading progress */
.progress-bar {
    width: 100%;
    height: 4px;
    background: var(--gray-subtle);
    margin-top: 1rem;
}
.progress-fill {
    height: 100%;
    background: var(--text);
    transition: width 0.4s ease;
}
.discovery-score {
    font-size: 4rem;
    font-weight: 900;
    letter-spacing: -0.04em;
    line-height: 1;
    margin-bottom: 0.5rem;
}
.discovery-detail {
    font-size: 0.85rem;
    color: var(--gray-mid);
    margin-top: 0.5rem;
}
.next-section {
    padding: 1.5rem 4rem;
    border-top: 2px solid var(--border);
}
.chip-unvisited {
    display: inline-block;
    padding: 0.4rem 1rem;
    border: 2px dashed var(--border);
    text-decoration: none;
    color: var(--text);
    font-size: 0.875rem;
    transition: all 0.15s ease;
    letter-spacing: -0.01em;
}
.chip-unvisited:hover {
    background: var(--text);
    color: var(--bg);
    border-style: solid;
    transform: translateY(-2px);
    box-shadow: 2px 2px 0 var(--border);
}

/* Full-text search */
.search-result-excerpt {
    font-size: 0.75rem;
    color: var(--gray-mid);
    margin-top: 0.25rem;
    line-height: 1.4;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    max-width: 100%;
}
.search-result:hover .search-result-excerpt,
.search-result.active .search-result-excerpt {
    color: var(--bg);
    opacity: 0.8;
}
.search-result-excerpt mark,
.search-highlight {
    background: var(--text);
    color: var(--bg);
    padding: 0.1em 0.2em;
}
.search-result:hover .search-result-excerpt mark,
.search-result.active .search-result-excerpt mark {
    background: var(--bg);
    color: var(--text);
}
.search-highlight {
    animation: highlightPulse 1s ease 2;
}
@keyframes highlightPulse {
    0%, 100% { background: var(--text); color: var(--bg); }
    50% { background: var(--gray-subtle); color: var(--text); }
}

/* Graph analytics */
.analytics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    margin-top: 1rem;
}
.analytics-grid .block {
    opacity: 1;
    transform: none;
}

/* Community / Topics */
.view-toggle {
    padding: 0.35rem 1rem;
    border: 2px solid var(--border);
    background: var(--bg);
    color: var(--text);
    font-family: inherit;
    font-size: 0.8rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    cursor: pointer;
    transition: all 0.15s ease;
    margin-left: auto;
}
.view-toggle:hover,
.view-toggle.active {
    background: var(--text);
    color: var(--bg);
}
.topic-cluster {
    padding: 1.5rem 0;
    border-bottom: 1px solid var(--gray-subtle);
}
.topic-cluster:last-child {
    border-bottom: none;
}
.topic-header {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin-bottom: 1rem;
}
.topic-name {
    font-weight: 700;
    font-size: 1.1rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}
.topic-count {
    font-size: 0.75rem;
    color: var(--gray-mid);
}

/* Graph controls */
.graph-controls {
    position: absolute;
    bottom: 1rem;
    right: 1rem;
    display: flex;
    gap: 0.5rem;
    z-index: 10;
}
.graph-controls button {
    padding: 0.35rem 0.75rem;
    border: 2px solid var(--border);
    background: var(--bg);
    color: var(--text);
    font-family: inherit;
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    cursor: pointer;
    transition: all 0.15s ease;
}
.graph-controls button:hover,
.graph-controls button.active {
    background: var(--text);
    color: var(--bg);
}
.path-instruction {
    position: absolute;
    top: 1rem;
    left: 50%;
    transform: translateX(-50%);
    background: var(--bg-inverted);
    color: var(--text-inverted);
    padding: 0.4rem 1rem;
    font-size: 0.8rem;
    z-index: 10;
}

/* Timeline */
.timeline-page {
    border: 2px solid var(--border);
    margin: 1rem;
    display: flex;
    flex-direction: column;
    min-height: calc(100vh - 2rem);
    animation: fadeIn 0.3s ease;
}
.timeline-header {
    padding: 3rem 4rem;
    border-bottom: 2px solid var(--border);
}
.timeline-title {
    font-size: clamp(2.5rem, 6vw, 5rem);
    font-weight: 700;
    letter-spacing: -0.04em;
    line-height: 1;
    margin-bottom: 1rem;
}
.timeline-subtitle {
    font-size: 1rem;
    color: var(--gray-mid);
}
.timeline-canvas-container {
    position: relative;
    height: 400px;
    border-bottom: 2px solid var(--border);
    padding: 1rem 2rem;
}
.timeline-canvas-container canvas {
    width: 100%;
    height: 100%;
    display: block;
}
.timeline-tooltip {
    position: absolute;
    background: var(--bg);
    border: 2px solid var(--border);
    box-shadow: 4px 4px 0 var(--border);
    padding: 0.75rem 1rem;
    font-size: 0.8rem;
    max-width: 250px;
    pointer-events: none;
    z-index: 10;
}
.timeline-tooltip-title {
    font-weight: 700;
    margin-bottom: 0.5rem;
}
.timeline-tooltip-item {
    cursor: pointer;
    pointer-events: auto;
    padding: 0.15rem 0;
    text-decoration: underline;
    text-decoration-style: dashed;
    text-underline-offset: 2px;
}
.timeline-tooltip-item:hover {
    background: var(--text);
    color: var(--bg);
    text-decoration: none;
}

@media (max-width: 800px) {
    .next-section {
        padding-left: 2rem;
        padding-right: 2rem;
    }
    .timeline-header {
        padding-left: 2rem;
        padding-right: 2rem;
    }
}
@media (max-width: 500px) {
    .next-section {
        padding-left: 1.5rem;
        padding-right: 1.5rem;
    }
    .timeline-header {
        padding-left: 1.5rem;
        padding-right: 1.5rem;
    }
    .timeline-canvas-container {
        height: 250px;
        padding: 0.5rem 1rem;
    }
    .analytics-grid {
        grid-template-columns: 1fr 1fr;
    }
    .timeline-page {
        margin: 0.5rem;
        min-height: calc(100vh - 1rem);
    }
    .graph-controls {
        bottom: 0.5rem;
        right: 0.5rem;
    }
}
</style>
</head>
<body>
<div id="app"></div>

<script>
const { createApp, computed, ref, watch, onMounted } = Vue;
const { createRouter, createWebHistory, useRoute, useRouter } = VueRouter;

// Grammar words to skip for inline linking
const SKIP_WORDS = new Set(['the', 'of', 'at', 'and', 'that', 'not', 'just', 'where']);

// All word keys for wander
const ALL_WORDS = () => Object.keys(wordData);

// Reading time helper
function readingTime(html) {
    if (!html) return 0;
    const words = html.replace(/<[^>]*>/g, '').split(/\s+/).filter(Boolean).length;
    return Math.max(1, Math.round(words / 200));
}

// Time ago helper
function timeAgo(dateStr) {
    if (!dateStr) return '';
    const [y, m] = dateStr.split('-').map(Number);
    const planted = new Date(y, m - 1);
    const now = new Date();
    const months = (now.getFullYear() - planted.getFullYear()) * 12 + (now.getMonth() - planted.getMonth());
    if (months < 1) return 'this month';
    if (months === 1) return '1 month ago';
    if (months < 12) return months + ' months ago';
    const years = Math.floor(months / 12);
    if (years === 1) return '1 year ago';
    return years + ' years ago';
}

// Breadcrumb trail
function getTrail() {
    try {
        return JSON.parse(sessionStorage.getItem('garden-trail') || '[]');
    } catch { return []; }
}
function addToTrail(word) {
    let trail = getTrail();
    trail = trail.filter(w => w !== word);
    trail.push(word);
    if (trail.length > 5) trail = trail.slice(-5);
    sessionStorage.setItem('garden-trail', JSON.stringify(trail));
}

// Reading progress helpers
function getVisited() {
    try { return JSON.parse(localStorage.getItem('garden-visited') || '{"words":[],"notes":[]}'); }
    catch { return { words: [], notes: [] }; }
}
function markVisited(type, id) {
    const v = getVisited();
    const arr = type === 'word' ? v.words : v.notes;
    if (!arr.includes(id)) { arr.push(id); localStorage.setItem('garden-visited', JSON.stringify(v)); }
}
function isVisited(type, id) {
    const v = getVisited();
    return (type === 'word' ? v.words : v.notes).includes(id);
}
function getDiscoveryScore() {
    const v = getVisited();
    const totalWords = Object.keys(wordData).length;
    const totalNotes = Object.keys(notesData).length;
    const total = totalWords + totalNotes;
    if (total === 0) return 0;
    return Math.round(((v.words.length + v.notes.length) / total) * 100);
}
function getUnvisitedConnections(wordId) {
    const data = wordData[wordId];
    if (!data) return [];
    const related = data.related || [];
    const backlinks = getBacklinks(wordId);
    const notes = getNotesForWord(wordId).map(n => ({ type: 'note', id: n.id, label: n.title }));
    const wordConns = [...new Set([...related, ...backlinks])].map(w => ({ type: 'word', id: w, label: w }));
    return [...wordConns, ...notes].filter(c => !isVisited(c.type, c.id)).slice(0, 3);
}

// Word data store
const wordData = {
    building: {
        related: ['systems', 'source', 'adapt', 'from'],
        stage: 'evergreen',
        planted: '2017-01',
        tended: '2025-12',
        blocks: [
            {
                title: "Current Projects",
                items: [
                    "copilot: CLI Copilot in Rust",
                    "orbit: Spatial Terminal Dashboard",
                    "speculative-decoding: Fast LLM on Apple Silicon",
                    "paddleocr-vl.swift: OCR with MLX",
                    "tanstack-bun: SSR with Bun"
                ]
            },
            {
                title: "Focus Areas",
                items: [
                    "ML Inference: MLX-Swift, Apple Silicon",
                    "Developer Tools: Rust CLI, TUIs",
                    "Web & Graphics: WebGL2/WebGPU",
                    "Automation: Telegram bots"
                ]
            },
            {
                title: "Stats",
                items: [
                    "30+ public repositories",
                    "9 languages",
                    "First commit: 2017",
                    "7+ years shipping code"
                ]
            }
        ]
    },
    at: {
        related: ['from', 'building', 'the'],
        stage: 'seed',
        planted: '2025-01',
        tended: '2025-01',
        blocks: [
            { title: "Location", text: "Software engineer from India. Building developer tools, ML inference systems, and automation that works." }
        ]
    },
    the: {
        related: ['of', 'and'],
        stage: 'seed',
        planted: '2025-01',
        tended: '2025-01',
        blocks: [
            { title: "Definite Article", text: "The most common word in English. Used here to specify a particular intersection." }
        ]
    },
    intersection: {
        related: ['computation', 'cognition', 'first', 'principles'],
        stage: 'sprout',
        planted: '2024-06',
        tended: '2025-06',
        blocks: [
            { title: "Where Fields Meet", text: "The space where computation, cognition, and first principles overlap. This intersection is where novel insights emerge." },
            {
                title: "Cross-Disciplinary Insights",
                items: ["Neural computation theory", "Cognitive architectures", "Verified AI systems", "Principled machine learning"]
            }
        ]
    },
    of: {
        related: ['the', 'and', 'at'],
        stage: 'seed',
        planted: '2025-01',
        tended: '2025-01',
        blocks: [
            { title: "Preposition", text: "Expressing the relationship between a part and a whole. The intersection is composed of these elements." }
        ]
    },
    computation: {
        related: ['cognition', 'systems', 'parallel', 'runtimes', 'execute', 'reason'],
        stage: 'evergreen',
        planted: '2020-03',
        tended: '2025-12',
        blocks: [
            { title: "ML Inference", text: "Making LLMs run fast on consumer hardware. Native Swift implementations using MLX for Apple Silicon." },
            {
                title: "Projects",
                items: ["speculative-decoding: MLX-Swift port", "nano-reasoning: FastRL on Apple Silicon", "paddleocr-vl.swift: 0.9B doc parsing VLM", "masked: Masked diffusion LM"]
            },
            {
                title: "Hardware Targets",
                items: ["Apple Silicon (MLX)", "GPU: WebGL2/WebGPU", "CPU: Rust simd optimization"]
            }
        ]
    },
    cognition: {
        related: ['computation', 'learn', 'adapt', 'reason', 'systems'],
        stage: 'evergreen',
        planted: '2020-06',
        tended: '2025-10',
        blocks: [
            { title: "neurodiverse", text: "Research and Development for AI powered Memory Prosthetics. Exploring how systems can learn and adapt." },
            {
                title: "Memory Systems",
                items: ["Information retrieval", "Similarity search (HNSW)", "Semantic embeddings", "Long-term context"]
            },
            {
                title: "Projects",
                items: ["sentence-similarity-search", "discover: search engine", "masked: diffusion LM"]
            }
        ]
    },
    and: {
        related: ['of', 'the', 'at'],
        stage: 'seed',
        planted: '2025-01',
        tended: '2025-01',
        blocks: [
            { title: "Conjunction", text: "Connects words, phrases, or clauses. Indicates addition or connection between concepts." }
        ]
    },
    first: {
        related: ['principles', 'foundations', 'reason'],
        stage: 'seed',
        planted: '2023-01',
        tended: '2025-06',
        blocks: [
            { title: "First Principles Thinking", text: "Break down problems to their fundamental truths. Build up from there. Don't reason by analogy." },
            {
                title: "Process",
                items: ["Identify the problem", "Break into components", "Find fundamental truths", "Build from ground up", "Verify each step"]
            },
            {
                title: "Applications",
                items: ["Compiler design", "System architecture", "Algorithm invention", "Language creation"]
            }
        ]
    },
    principles: {
        related: ['first', 'minimal', 'foundations', 'verifiable', 'everything'],
        stage: 'evergreen',
        planted: '2023-01',
        tended: '2025-12',
        blocks: [
            { number: "01", title: "Understand Before Building", text: "If you cannot explain it simply, you do not understand it well enough." },
            { number: "02", title: "Dependencies Are Liabilities", text: "Prefer 100 lines of your own code over a dependency you don't fully understand." },
            { number: "03", title: "Simplicity Is Requisite", text: "Complexity is the enemy of reliability." },
            { number: "04", title: "Build for the Long Term", text: "Code should last decades, not quarters." }
        ]
    },
    systems: {
        related: ['computation', 'building', 'minimal', 'runtimes', 'parallel', 'everything'],
        stage: 'evergreen',
        planted: '2017-01',
        tended: '2025-12',
        blocks: [
            { stat: "7+", label: "Years Shipping", text: "Software engineer from India. Building developer tools, ML inference systems, and automation that works." },
            {
                title: "Systems I Build",
                items: ["ML inference on Apple Silicon", "Rust CLI tools", "WebGL2/WebGPU rendering", "Telegram automation", "Information retrieval"]
            },
            {
                title: "Properties",
                items: ["Fast: Performance first", "Minimal: Less code, better results", "Reliable: Production tested", "Auditable: Open source"]
            }
        ]
    },
    that: {
        related: ['systems', 'learn'],
        stage: 'seed',
        planted: '2025-01',
        tended: '2025-01',
        blocks: [
            { title: "Subordinating Conjunction", text: "Introduces a subordinate clause expressing a statement. Connects the systems to their capabilities." }
        ]
    },
    learn: {
        related: ['adapt', 'reason', 'cognition', 'systems'],
        stage: 'evergreen',
        planted: '2017-01',
        tended: '2025-12',
        blocks: [
            {
                title: "Timeline",
                items: ["2024: MLX-Swift & Apple Silicon", "2023: Rust & Developer Tools", "2020: Information Retrieval", "2017: Telegram Bots"]
            },
            {
                title: "Languages",
                items: ["Rust: Systems & CLI", "Swift: Native & ML", "TypeScript: Web", "Python: Prototyping"]
            },
            {
                title: "Stack",
                items: ["Node.js / Bun", "React / Svelte / Vue", "PostgreSQL / Redis", "Docker / AWS / Cloudflare"]
            }
        ]
    },
    adapt: {
        related: ['learn', 'reason', 'cognition', 'building'],
        stage: 'evergreen',
        planted: '2017-01',
        tended: '2025-12',
        blocks: [
            { title: "Evolution", text: "2017: Telegram bots. 2020: Information retrieval. 2023: Rust & systems. 2024: MLX & Apple Silicon. Always adapting." },
            {
                title: "Services",
                items: ["Product Development: MVPs to production", "Architecture: APIs, databases, infra", "Performance: Optimization & caching", "Emergencies: Crisis response"]
            },
            { title: "Hire", text: "Available for contract work at $1,000/day. Book a 30min call to discuss your project." }
        ]
    },
    reason: {
        related: ['learn', 'adapt', 'cognition', 'computation', 'first'],
        stage: 'evergreen',
        planted: '2024-01',
        tended: '2025-12',
        blocks: [
            { title: "nano-reasoning", text: "High-performance port of FastRL to Apple Silicon using MLX-Swift. Reasoning models that run locally on consumer hardware." },
            {
                title: "Research",
                items: ["FastRL inference optimization", "On-device reasoning", "Speculative decoding for reasoning"]
            },
            { title: "Goal", text: "Systems that understand what they're doing, not just pattern match. Local, private, fast reasoning." }
        ]
    },
    not: {
        related: ['just', 'execute'],
        stage: 'seed',
        planted: '2025-01',
        tended: '2025-01',
        blocks: [
            { title: "Negation", text: "The most important word in logic. Systems that reason, not just execute." },
            {
                title: "What I Don't Do",
                items: ["Enterprise consulting", "Blockchain/Web3", "Mobile app development", "Legacy system maintenance"]
            }
        ]
    },
    just: {
        related: ['not', 'execute'],
        stage: 'seed',
        planted: '2025-01',
        tended: '2025-01',
        blocks: [
            { title: "Merely / Only", text: "Used to minimize or dismiss. 'Just execute,' the bare minimum. We aim higher than just execution." }
        ]
    },
    execute: {
        related: ['not', 'just', 'runtimes', 'computation'],
        stage: 'sprout',
        planted: '2024-03',
        tended: '2025-08',
        blocks: [
            { title: "Beyond Execution", text: "Current software merely executes. The goal is systems that understand what they are doing." },
            {
                title: "Execution Models",
                items: ["Von Neumann: Sequential", "Dataflow: Demand-driven", "Interaction nets: Parallel rewriting", "GPU: SIMD execution"]
            },
            { title: "Performance", text: "Execution speed matters, but correctness matters more. Fast wrong answers are useless." }
        ]
    },
    verifiable: {
        related: ['foundations', 'principles', 'auditable', 'source'],
        stage: 'evergreen',
        planted: '2023-06',
        tended: '2025-10',
        blocks: [
            { check: "\u2713", title: "Formal Verification", text: "Mathematical proofs of correctness. No testing can prove absence of bugs, but proofs can." },
            {
                title: "Techniques",
                items: ["Type systems as proofs", "Model checking", "SMT solvers", "Interactive theorem proving"]
            },
            {
                title: "Projects",
                items: ["verified-zig: Proven allocator", "safe-ir: Verified intermediate rep", "types-rs: Rust type checker proof"]
            }
        ]
    },
    foundations: {
        related: ['first', 'principles', 'verifiable', 'computation'],
        stage: 'evergreen',
        planted: '2023-01',
        tended: '2025-10',
        blocks: [
            {
                title: "Mathematical Base",
                items: ["Type theory: The language of structure", "Category theory: Abstract patterns", "Topology: Continuous reasoning", "Logic: Truth and consequence"]
            },
            {
                title: "Computing Base",
                items: ["Lambda calculus: Universal computation", "Combinatory logic: Variable-free", "Interaction nets: Parallel models", "Assembly: The metal"]
            },
            { title: "Philosophy", text: "Build from bedrock. Understand the ground beneath your feet." }
        ]
    },
    massively: {
        related: ['parallel', 'runtimes', 'computation', 'systems'],
        stage: 'sprout',
        planted: '2024-01',
        tended: '2025-06',
        blocks: [
            { number: "10\u2076", title: "Parallel Units", text: "Modern GPUs execute millions of threads simultaneously." },
            {
                title: "Scale Targets",
                items: ["GPU: 10,000+ cores", "CPU: 64+ threads", "Cluster: 1000+ nodes", "Edge: 100+ devices"]
            }
        ]
    },
    parallel: {
        related: ['massively', 'runtimes', 'computation'],
        stage: 'sprout',
        planted: '2024-01',
        tended: '2025-08',
        blocks: [
            { title: "MLX Parallelism", text: "Apple Silicon unified memory architecture allows efficient parallel computation." },
            { title: "paragon", text: "Provably correct, high-performance model training using Bend's massively parallel capabilities." },
            {
                title: "Hardware",
                items: ["Apple Neural Engine", "GPU compute shaders", "Multi-core CPU"]
            }
        ]
    },
    runtimes: {
        related: ['parallel', 'massively', 'computation', 'systems', 'execute'],
        stage: 'sprout',
        planted: '2023-06',
        tended: '2025-10',
        blocks: [
            { title: "Custom Runtimes", text: "Execution environments designed for specific computational models. Specialized for efficiency and correctness." },
            {
                title: "Implementations",
                items: ["inets: Interaction net runtime", "tensor-rt: GPU compute runtime", "wasm-kernel: Browser runtime", "predictive-rt: Inference engine"]
            },
            {
                title: "Design Goals",
                items: ["Minimal overhead", "Predictable performance", "No garbage collection", "Static memory"]
            }
        ]
    },
    everything: {
        related: ['minimal', 'systems', 'principles'],
        stage: 'sprout',
        planted: '2024-01',
        tended: '2025-06',
        blocks: [
            { title: "Universal Application", text: "These principles apply to all systems. No exceptions." },
            { title: "Scope", text: "Code, documentation, tests, processes. Everything is subject to the same standards." }
        ]
    },
    minimal: {
        related: ['everything', 'small', 'footprint', 'zero', 'dependencies', 'principles'],
        stage: 'evergreen',
        planted: '2020-01',
        tended: '2025-12',
        blocks: [
            { title: "Philosophy", text: "Every line of code is a liability. Fewer dependencies, simpler architectures, less to break." },
            {
                title: "Writing",
                items: ["The case for minimal software", "Shipping fast without breaking things"]
            },
            {
                title: "Principles",
                items: ["Every feature earns its place", "Question every dependency", "Remove before you add", "Complexity is a last resort"]
            }
        ]
    },
    small: {
        related: ['minimal', 'footprint', 'zero'],
        stage: 'sprout',
        planted: '2023-06',
        tended: '2025-06',
        blocks: [
            {
                title: "Size Metrics",
                items: ["Lines of code", "Binary size", "Memory footprint", "API surface", "Dependency count"]
            },
            { title: "Why Small Matters", text: "Small systems are comprehensible. They fit in a human mind." }
        ]
    },
    footprint: {
        related: ['small', 'minimal', 'zero'],
        stage: 'sprout',
        planted: '2023-06',
        tended: '2025-08',
        blocks: [
            { stat: "50KB", title: "Binary Size", text: "inets compiles to a 50KB static binary. No external dependencies." },
            {
                title: "Memory Footprint",
                items: ["No garbage collector", "Static allocation where possible", "Predictable memory usage", "No memory leaks"]
            },
            { title: "Environmental Impact", text: "Small software uses less energy. It runs on older hardware. It reduces e-waste." }
        ]
    },
    zero: {
        related: ['dependencies', 'minimal', 'small', 'footprint'],
        stage: 'evergreen',
        planted: '2020-01',
        tended: '2025-12',
        blocks: [
            { zero: true, title: "Zero Dependencies", text: "Each library you add is code you don't control. It can break, have security issues, bloat your bundle." },
            {
                title: "Projects",
                items: ["tanstack-bun: Zero overhead SSR", "orbit: Pure Rust TUI", "copilot: Single binary"]
            },
            { title: "Exceptions", text: "Where possible. Practical constraints sometimes require compromise." }
        ]
    },
    dependencies: {
        related: ['zero', 'minimal', 'auditable', 'possible'],
        stage: 'evergreen',
        planted: '2020-01',
        tended: '2025-12',
        blocks: [
            {
                title: "The Dependency Problem",
                items: ["Supply chain attacks (log4j, xz)", "Left-pad incidents", "Version hell", "Audit impossibility"]
            },
            {
                title: "Solutions",
                items: ["Vendor critical code", "Reimplement trivial functions", "Use standard libraries", "Static linking"]
            },
            { title: "Policy", text: "Zero runtime dependencies. Every dependency requires justification." }
        ]
    },
    where: {
        related: ['possible'],
        stage: 'seed',
        planted: '2025-01',
        tended: '2025-01',
        blocks: [
            { title: "Adverb", text: "Indicates the condition under which something applies. Zero dependencies where possible acknowledges practical constraints." }
        ]
    },
    possible: {
        related: ['where', 'dependencies'],
        stage: 'seed',
        planted: '2025-01',
        tended: '2025-01',
        blocks: [
            { title: "Practical Constraints", text: "Ideals are aspirational. Sometimes external constraints require compromises." },
            {
                title: "Acceptable Exceptions",
                items: ["Hardware drivers", "Platform APIs", "Crypto libraries (audited)", "Build tools"]
            }
        ]
    },
    auditable: {
        related: ['source', 'verifiable', 'dependencies'],
        stage: 'evergreen',
        planted: '2020-06',
        tended: '2025-10',
        blocks: [
            { title: "Code You Can Read", text: "Every system I build can be understood by reading the source. I write Rust, Swift, TypeScript, and Python with clarity first." },
            {
                title: "Public Work",
                items: ["github.com/lulzx: 30+ public repos", "CLI tools in Rust", "MLX-Swift inference ports", "Web libraries"]
            },
            { title: "Open Source", text: "Most of my work is open source. 7+ years of shipping code you can inspect." }
        ]
    },
    from: {
        related: ['building', 'source', 'at'],
        stage: 'sprout',
        planted: '2024-01',
        tended: '2025-06',
        blocks: [
            { title: "Origin", text: "Software engineer from India. Building developer tools, ML inference systems, and automation that works." },
            { title: "Location", text: "Based in India, working remotely with teams worldwide. Available for contract work at $1,000/day." },
            {
                title: "History",
                items: ["2017: Started with Telegram bots", "2020: Information retrieval systems", "2023: Rust & developer tools", "2024: MLX-Swift & Apple Silicon"]
            }
        ]
    },
    source: {
        related: ['auditable', 'from', 'building'],
        stage: 'evergreen',
        planted: '2017-01',
        tended: '2025-12',
        blocks: [
            { title: "GitHub", text: "github.com/lulzx: 30+ public repositories. 9 languages. Open source work you can audit, modify, and learn from." },
            {
                title: "Featured Repos",
                items: ["copilot: Rust CLI AI assistant", "orbit: Spatial TUI dashboard", "speculative-decoding: MLX-Swift", "tanstack-bun: SSR framework"]
            },
            { title: "License", text: "Most projects are MIT licensed. Free to use, modify, and distribute." }
        ]
    }
};

// Notes data store
const notesData = {
    'minimal-software': {
        title: 'Less code',
        stage: 'evergreen',
        planted: '2024-10',
        tended: '2026-01',
        words: ['minimal', 'dependencies', 'small', 'footprint', 'zero', 'principles'],
        relatedNotes: ['the-100-line-rule', 'one-file'],
        content: `<p>I keep coming back to this: the best code is the code I didn't write.</p>
<p>Not in a lazy way. In a <em>if this line doesn't need to exist, it shouldn't</em> way.</p>
<p>Every line I add is a line I have to maintain. A line that can break. A line someone else has to read and understand. Including future me, who will have forgotten why it's there.</p>
<h2>What I actually do</h2>
<p>Before I add a feature, I try to remove one. Before I add a file, I check if an existing one can hold it. Before I add a dependency, I look at how many lines it would take to write myself.</p>
<p>Usually fewer than I think.</p>
<p>My site is one HTML file. My CLI tools compile to single binaries. My libraries have zero runtime dependencies. Not because I'm trying to prove something. Because every time I've done it the other way, I've regretted it.</p>
<h2>The hard part</h2>
<p>Removing is harder than adding. Always. Your brain wants to solve problems by creating things. It takes real discipline to solve them by destroying things instead.</p>
<p>But the projects I'm most proud of are the ones where I looked at the code and thought "there's nothing left to take away."</p>`
    },
    'shipping-fast': {
        title: 'Ship small, ship often',
        stage: 'evergreen',
        planted: '2025-12',
        tended: '2026-01',
        words: ['systems', 'building', 'adapt', 'execute', 'minimal'],
        relatedNotes: ['worse-is-better', 'minimal-software'],
        content: `<p>The fastest teams I've worked with shipped the smallest changes.</p>
<p>Not because small is easy. Because small is <em>safe</em>. A 30-line diff is easy to review, easy to test, easy to revert if it breaks. A 3000-line diff is a prayer.</p>
<p>I used to batch things up. "I'll ship all of this together when it's ready." It was never ready. And when I finally pushed, something always broke, and I couldn't tell which part did it.</p>
<p>Now I ship constantly. Multiple times a day sometimes. Each change does one thing. If it breaks, I know exactly what and exactly why.</p>
<h2>The counterintuitive part</h2>
<p>Going faster means doing less per step. Not more. The urge is always to do more. Add the error handling, refactor that other thing while you're in there, fix that bug you noticed. Don't.</p>
<p>One thing. Ship it. Next thing.</p>
<p>Deploy should be boring. If it's exciting, you're doing it wrong.</p>`
    },
    'telegram-bots': {
        title: 'Seven years of Telegram bots',
        stage: 'evergreen',
        planted: '2024-06',
        tended: '2026-01',
        words: ['systems', 'building', 'adapt', 'learn', 'runtimes'],
        relatedNotes: ['learn-by-building', 'shipping-fast'],
        content: `<p>I started building Telegram bots in 2017 because I was bored. Wrote one that replied to messages with random quotes. Took maybe an hour.</p>
<p>That was the gateway drug.</p>
<p>Seven years later, some of my bots handle millions of messages a day. I've learned more about building reliable systems from bots than from any job or course.</p>
<h2>The one thing that matters</h2>
<p>Webhooks, not polling. That's it. That's the entire scaling secret. Polling is you calling Telegram every second asking "anything new?" Webhooks are Telegram calling <em>you</em> when something happens.</p>
<p>After that, it's the same stuff that makes any system work: queue your messages, process them async, cache aggressively, and log everything.</p>
<h2>What bots taught me</h2>
<p>Bots fail constantly. The API times out. Users send garbage. Your server runs out of memory at 3am. You learn to build for failure because you have no choice.</p>
<p>A bot that crashes and recovers gracefully is infinitely better than one that never crashes but silently drops messages. I apply this to everything I build now.</p>
<p>Most of what I know about distributed systems, I learned from a chat bot.</p>`
    },
    'semver-30x-faster': {
        title: 'semver, but 30x faster',
        stage: 'evergreen',
        planted: '2025-12',
        tended: '2026-01',
        words: ['computation', 'minimal', 'zero', 'dependencies', 'small', 'footprint', 'execute'],
        relatedNotes: ['minimal-software', 'the-100-line-rule'],
        content: `<p>Every <code>npm install</code> parses version strings. Thousands of them. Installing preact alone calls <code>semver</code> 21,000 times. One package.</p>
<p>The <code>semver</code> package has 150 million weekly downloads. And it's doing way more work than it needs to.</p>
<h2>The dumb idea</h2>
<p>Version numbers aren't random. React is at 18. Node is at 22. Most packages never pass major version 50. So I precomputed all of them.</p>
<pre><code>const cache = Object.create(null);
for (let M = 0; M &lt; 50; M++)
  for (let m = 0; m &lt; 50; m++)
    for (let p = 0; p &lt; 20; p++)
      cache[M+'.'+m+'.'+p] = {major: M, minor:m, patch:p};</code></pre>
<p>50,000 objects. Allocated once. Now parsing <code>1.0.0</code> is just a hash lookup. No regex. No nothing.</p>
<h2>Then compile the ranges</h2>
<p><code>^1.2.3</code> always means the same thing. So compile it once to a closure:</p>
<pre><code>(M, m, p, pr) =&gt; !pr && M === 1 && ((m-2)||(p-3)) >= 0</code></pre>
<p>Next time you check any version against <code>^1.2.3</code>, it's four integers and some arithmetic. Done.</p>
<h2>Result</h2>
<p><strong>208 million</strong> parses per second. 35x faster. 6.4 kB gzipped. Zero dependencies.</p>
<p>Half my ideas didn't work. Hash arrays were slower than V8's internals. Fast-path parsing added overhead because the cache was already fast enough. Benchmark everything. Your gut is wrong.</p>
<p><a href="https://github.com/Lulzx/pico-semver">github.com/Lulzx/pico-semver</a></p>`
    },
    'the-100-line-rule': {
        title: 'The 100-line rule',
        stage: 'evergreen',
        planted: '2023-06',
        tended: '2026-01',
        words: ['dependencies', 'zero', 'minimal', 'small', 'principles'],
        relatedNotes: ['minimal-software', 'do-it-yourself'],
        content: `<p>If a dependency is less than 100 lines of code, I write it myself.</p>
<p>Not because I think I'm smarter than the library author. Because I think 100 lines I understand completely is better than 100 lines I don't.</p>
<p>Left-pad was 11 lines. It broke the internet. I could have written it in 30 seconds. So could you. So could anyone. But 2.5 million projects depended on one person not deleting their npm package.</p>
<p>I have a utils file in most of my projects. It has debounce, throttle, deep clone, a couple of string helpers. Maybe 80 lines total. I've never had a supply chain attack on my utils file.</p>
<p>The threshold isn't really 100 lines. It's: <em>can I understand every line of this?</em> If yes, I own it. If no, I think very hard about whether I need it.</p>`
    },
    'do-it-yourself': {
        title: 'npm install regret',
        stage: 'evergreen',
        planted: '2023-03',
        tended: '2025-10',
        words: ['dependencies', 'zero', 'minimal', 'building', 'source'],
        relatedNotes: ['the-100-line-rule', 'minimal-software'],
        content: `<p>I used to <code>npm install</code> everything. Need to pad a string? Package. Parse a date? Package. Check if a number is even? Believe it or not, package.</p>
<p>Then I'd open <code>node_modules</code> and find 800 folders for a project that sends emails.</p>
<p>The turning point was a security audit. I had to explain every dependency. Why do we need this? What does it do? Can we trust the maintainer? I couldn't answer for half of them. I'd installed packages I'd never read a single line of.</p>
<p>Now I default to writing it myself. Most things I need are 20-50 lines. The ones that aren't (crypto, compression, database drivers) I add thoughtfully and pin the version.</p>
<p>My <code>node_modules</code> went from 800 folders to about 30. My builds are faster. My deploys are smaller. And I actually know what my code does.</p>`
    },
    'rust-changed-my-brain': {
        title: 'Rust rewired my brain',
        stage: 'evergreen',
        planted: '2023-01',
        tended: '2025-12',
        words: ['computation', 'systems', 'learn', 'foundations'],
        relatedNotes: ['learn-by-building', 'speed-is-a-feature'],
        content: `<p>I picked up Rust in 2023 expecting a language. I got a way of thinking.</p>
<p>The borrow checker isn't a restriction. It's a question: <em>who owns this data?</em> I'd never asked that before. In Python and JavaScript, the answer was "who cares, the garbage collector will figure it out." In Rust, you have to know.</p>
<p>Now I think about ownership in every language. When I write TypeScript, I notice when I'm passing references carelessly. When I design an API, I think about who's responsible for cleanup. Rust didn't teach me Rust. It taught me to think about data.</p>
<p>The other thing: Rust made me comfortable with the compiler saying no. In dynamic languages, you discover mistakes at runtime. In Rust, the compiler catches them. At first this felt slow. Now every other language feels reckless.</p>
<p>I still write TypeScript and Python when they're the right tool. But I write them differently than I used to.</p>`
    },
    'read-the-source': {
        title: 'Read the source',
        stage: 'evergreen',
        planted: '2020-06',
        tended: '2025-08',
        words: ['source', 'auditable', 'learn', 'foundations'],
        relatedNotes: ['rust-changed-my-brain', 'learn-by-building'],
        content: `<p>The best programmers I know spend more time reading code than writing it.</p>
<p>I used to think building things was how you got good. It's part of it. But the other part is reading how other people solved the same problem. Not blog posts <em>about</em> the code. The actual code.</p>
<p>I learned more from reading the Redis source than from any database course. It's 50,000 lines of beautifully clear C. Every function does what its name says. The comments explain <em>why</em>, not <em>what</em>.</p>
<p>When I'm stuck on a design decision, I look at how someone I respect solved it. Not Stack Overflow. Not a tutorial. The source. It's always there. Most things worth learning from are open source.</p>
<p>Reading code is a skill nobody teaches and everyone needs.</p>`
    },
    'speed-is-a-feature': {
        title: 'Speed is respect',
        stage: 'evergreen',
        planted: '2024-03',
        tended: '2025-12',
        words: ['computation', 'execute', 'minimal', 'systems', 'footprint'],
        relatedNotes: ['semver-30x-faster', 'minimal-software'],
        content: `<p>Every millisecond you waste is a millisecond of someone's life.</p>
<p>That sounds dramatic. But multiply it. A page that takes 2 seconds instead of 200ms, loaded 10,000 times a day. That's 5 hours of human life wasted. Every day. On one page.</p>
<p>Performance isn't a technical concern. It's a moral one. When your software is slow, you're saying: my time was more valuable than yours. I couldn't be bothered to optimize this.</p>
<p>I don't mean premature optimization. I mean: choose the right data structure. Don't load what you don't need. Don't make the user wait for something you could have precomputed.</p>
<p>The fastest software I use is the software I forget is there. It just does the thing instantly and gets out of the way. That's what respect looks like in code.</p>`
    },
    'apple-silicon': {
        title: 'The M1 broke my assumptions',
        stage: 'sprout',
        planted: '2024-01',
        tended: '2025-10',
        words: ['computation', 'parallel', 'runtimes', 'systems'],
        relatedNotes: ['rust-changed-my-brain', 'speed-is-a-feature'],
        content: `<p>In 2024 I started porting ML models to Apple Silicon using MLX-Swift. I expected it to be a compromise. Run models locally, sure, but slowly.</p>
<p>It wasn't slow.</p>
<p>Unified memory changes everything. The GPU and CPU share the same RAM. No copying tensors back and forth. You just... use it. A 14-inch laptop running inference faster than my old cloud GPU setup.</p>
<p>I ported speculative decoding. Then a reasoning model. Then an OCR pipeline. Each time I expected to hit a wall. Each time the wall wasn't there.</p>
<p>The assumption I had to break: "real ML needs a data center." No. Real ML needs good hardware and good software. A MacBook has both now.</p>
<p>The models run locally. No API calls. No latency. No sending private data to someone else's server. I think this is the future and most people haven't realized it yet.</p>`
    },
    'learn-by-building': {
        title: 'Learn by building',
        stage: 'evergreen',
        planted: '2017-06',
        tended: '2025-12',
        words: ['learn', 'building', 'adapt', 'systems'],
        relatedNotes: ['seven-years', 'telegram-bots'],
        content: `<p>I never finished a programming course. I've started dozens. Never finished one.</p>
<p>What I did instead: I built things. A bot that tells you the weather. A search engine for my bookmarks. A CLI tool that does one thing I needed.</p>
<p>Each one taught me exactly what I needed to know, exactly when I needed to know it. Not "here's how arrays work" in week 3 of a curriculum. But "I need to sort these results by relevance, how do I do that?" at 1am on a Tuesday because I'm obsessed with my side project.</p>
<p>Courses teach you syntax. Projects teach you engineering. The difference is that projects have real constraints: this needs to actually work, for real users, on a real computer.</p>
<p>Build something small. Make it work. Make it better. That's the whole curriculum.</p>`
    },
    'one-file': {
        title: 'One file is enough',
        stage: 'sprout',
        planted: '2025-06',
        tended: '2026-02',
        words: ['minimal', 'small', 'building', 'everything', 'source'],
        relatedNotes: ['minimal-software', 'the-100-line-rule'],
        content: `<p>This website is one HTML file. The CSS, the JavaScript, the data, the components, the router. All in one file.</p>
<p>People ask why. The answer: why not?</p>
<p>One file means no build step. No bundler config. No module resolution. No "it works on my machine." Open the file, it works. Deploy the file, it's live.</p>
<p>There's a weird pressure in web development to have a "proper" project structure. Fourteen config files before you write a line of code. A build pipeline that takes longer than the actual program.</p>
<p>For a lot of projects, especially personal ones, none of that is necessary. You're not building Gmail. You're building a page that shows some text and links. One file handles that just fine.</p>
<p>I'll add complexity when I need it. So far I haven't needed it.</p>`
    },
    'worse-is-better': {
        title: 'Ship it ugly',
        stage: 'evergreen',
        planted: '2024-08',
        tended: '2025-10',
        words: ['building', 'adapt', 'execute', 'principles'],
        relatedNotes: ['shipping-fast', 'learn-by-building'],
        content: `<p>The first version of everything I've shipped was embarrassing.</p>
<p>My first Telegram bot was 200 lines of spaghetti Python with hardcoded strings. It worked. People used it. I cleaned it up later.</p>
<p>My first Rust CLI was a single main.rs with no error handling. It worked. I used it daily. I refactored it later.</p>
<p>This website was a plain HTML page with no CSS for a week. It worked. You're reading the better version. But the ugly version came first.</p>
<p>I've watched people spend months "getting it right" before showing anyone. They burn out or lose interest. The project dies in a private repo, perfect and unseen.</p>
<p>Ship the ugly version. See if anyone cares. If they do, make it less ugly. If they don't, you just saved yourself months of polishing something nobody wanted.</p>`
    },
    'remote-from-india': {
        title: 'The timezone advantage',
        stage: 'sprout',
        planted: '2024-04',
        tended: '2025-06',
        words: ['building', 'adapt', 'from', 'systems'],
        relatedNotes: ['seven-years', 'shipping-fast'],
        content: `<p>I'm in India. Most of my clients are in the US or Europe. People think this is a disadvantage. It's not.</p>
<p>When my American clients go to sleep, I start working. When they wake up, the thing they asked for is done. It feels like magic to them. It's just timezones.</p>
<p>The async part is key. I don't do meetings if I can avoid it. Write it down. Put it in a ticket. I'll read it and respond with code.</p>
<p>Meetings across timezones are miserable for everyone. But a well-written message works in every timezone. I've had entire client relationships where we never had a single call. Just messages and pull requests. The work spoke for itself.</p>
<p>Remote work isn't about being in the same room at the same time. It's about being reliable and clear. That works from anywhere.</p>`
    },
    'seven-years': {
        title: 'Seven years of shipping code',
        stage: 'evergreen',
        planted: '2024-01',
        tended: '2026-01',
        words: ['building', 'learn', 'adapt', 'systems', 'source'],
        relatedNotes: ['learn-by-building', 'rust-changed-my-brain'],
        content: `<p>2017: Telegram bots in Python. Everything in one file. Deployed by SSH-ing into a $5 server and running <code>python bot.py</code>.</p>
<p>2018: Discovered Node.js. Rewrote everything. Thought callbacks were fine. They weren't.</p>
<p>2019: Built an image search engine. Learned about vectors, embeddings, and why databases are hard.</p>
<p>2020: Information retrieval systems. HNSW, semantic search, the stuff that turned into "AI" a few years later.</p>
<p>2021: Burned out. Built nothing for three months. Came back and everything was better.</p>
<p>2023: Found Rust. Rewrote my CLI tools. Realized I'd been thinking about software wrong for years.</p>
<p>2024: Apple Silicon, MLX-Swift, running models locally that used to need a data center.</p>
<p>The through-line isn't a plan. I didn't have a five-year roadmap. I just kept building whatever interested me, and the interests kept changing. The only constant: I always shipped something.</p>
<p>Seven years of following curiosity. That's the whole career strategy.</p>`
    },
    'naming': {
        title: 'Names are interfaces',
        stage: 'seed',
        planted: '2025-03',
        tended: '2025-08',
        words: ['building', 'source', 'foundations', 'principles'],
        relatedNotes: ['read-the-source', 'one-file'],
        content: `<p>I spend more time naming things than writing the code inside them.</p>
<p>A function called <code>processData</code> tells me nothing. A function called <code>parseVersionString</code> tells me everything. The second one doesn't need a comment. The first one needs a paragraph.</p>
<p>Good names are compression. They pack meaning into a few characters. Bad names are debt. Every time someone reads <code>handleStuff</code>, they have to open the function and read the body to know what it does.</p>
<p>I rename things constantly. It's free. It doesn't change behavior. But it changes comprehension. And comprehension is everything when you're debugging at midnight and your brain is half off.</p>
<p>If I can't name something clearly, it usually means I don't understand it well enough yet. The naming struggle is a design signal.</p>`
    },
    'debugging': {
        title: 'Debug by reading',
        stage: 'seed',
        planted: '2025-06',
        tended: '2025-11',
        words: ['learn', 'source', 'execute', 'foundations'],
        relatedNotes: ['read-the-source', 'rust-changed-my-brain'],
        content: `<p>When something breaks, I don't reach for the debugger. I read the code.</p>
<p>Not skim. Read. Start from the entry point. Follow the data. Ask: what did I <em>think</em> this does? What does it <em>actually</em> do? The bug is in the gap between those two questions.</p>
<p>Debuggers are great for watching state. But they don't help you understand <em>why</em> the state is wrong. For that, you need to think. And thinking requires reading.</p>
<p>My debugging process: read, form a hypothesis, add one log to confirm or deny, repeat. Three rounds of this solves most bugs. The ones it doesn't are the interesting ones.</p>
<p>The best debugging tool is a good understanding of your own code. If you have that, you barely need anything else.</p>`
    },
    'tools-shape-thinking': {
        title: 'Your tools are your thoughts',
        stage: 'seed',
        planted: '2025-08',
        tended: '2025-12',
        words: ['computation', 'learn', 'foundations', 'systems'],
        relatedNotes: ['rust-changed-my-brain', 'learn-by-building'],
        content: `<p>I write different code in Rust than in Python. Not just syntactically. Structurally. The language shapes how I think about the problem.</p>
<p>In Python I prototype fast and sloppy. In Rust I design upfront because the compiler won't let me be sloppy. In TypeScript I lean on types to document intent. Each language is a different lens on the same problem.</p>
<p>Same with editors. Same with operating systems. Same with keyboards. Everything you use daily shapes how you think without you noticing.</p>
<p>I switched to a tiling window manager and started breaking problems into smaller, independent pieces. Coincidence? Maybe. But probably not.</p>
<p>Choose your tools deliberately. You become what you use.</p>`
    },
    'side-projects': {
        title: 'Side projects are the real work',
        stage: 'sprout',
        planted: '2024-06',
        tended: '2025-10',
        words: ['building', 'learn', 'source', 'adapt'],
        relatedNotes: ['learn-by-building', 'seven-years'],
        content: `<p>Everything good in my career came from a side project.</p>
<p>My first job came from a Telegram bot I built for fun. My freelance clients found me through open source repos. My best technical skills came from projects nobody asked me to build.</p>
<p>Side projects have one advantage over work projects: you choose the constraints. Want to learn Rust? Build something in Rust. Want to understand ML inference? Port a model. Nobody's telling you to use the company's approved stack.</p>
<p>I don't build side projects to "build a portfolio." I build them because I'm curious about something and the only way to understand it is to build it.</p>
<p>The portfolio is a side effect. The curiosity is the point.</p>`
    },
    'rewrite-it': {
        title: 'The second version',
        stage: 'sprout',
        planted: '2024-11',
        tended: '2025-12',
        words: ['building', 'learn', 'adapt', 'systems', 'minimal'],
        relatedNotes: ['worse-is-better', 'seven-years'],
        content: `<p>I rewrite things a lot. Not because the first version is bad. Because I understand the problem now.</p>
<p>The first time you build something, you're learning the domain. You make wrong abstractions. You over-engineer some parts and under-engineer others. You can't know the right design until you've built the wrong one.</p>
<p>The rewrite isn't starting over. It's starting informed.</p>
<p>I rewrote my search engine three times. Version one: Python, slow, wrong data structures. Version two: Node.js, faster, better architecture, still wrong in subtle ways. Version three: Rust, correct, fast, half the code of version one.</p>
<p>People say "don't rewrite." I think they mean "don't rewrite for fun." But rewriting because you now understand the problem deeply? That produces the best software I've ever written.</p>`
    },
    'boring-tech': {
        title: 'Pick boring technology',
        stage: 'evergreen',
        planted: '2024-02',
        tended: '2025-11',
        words: ['systems', 'building', 'dependencies', 'principles'],
        relatedNotes: ['shipping-fast', 'minimal-software'],
        content: `<p>PostgreSQL. Redis. A Linux server. That's it. That's the stack for 90% of what you'll ever build.</p>
<p>I spent years chasing new databases. Tried CockroachDB, FaunaDB, SurrealDB. Each one had a compelling pitch. Each one had weird edge cases nobody documented because nobody had hit them yet.</p>
<p>PostgreSQL has been hit with everything. Every edge case is documented. Every weird behavior has a Stack Overflow answer from 2014. That's not boring. That's battle-tested.</p>
<p>New technology is someone else's unfinished experiment. You're volunteering to be their QA team. Sometimes that's worth it. Usually it isn't.</p>
<p>I save my innovation budget for the thing that actually matters. The product. Everything under it should be as boring as possible.</p>`
    },
    'fail-loudly': {
        title: "Crash, don't hide",
        stage: 'evergreen',
        planted: '2023-09',
        tended: '2025-08',
        words: ['systems', 'execute', 'principles', 'building'],
        relatedNotes: ['telegram-bots', 'debugging'],
        content: `<p>The worst bugs are the ones that don't crash.</p>
<p>A null pointer exception at 3am is annoying but simple. You get a stack trace. You find the line. You fix it. A function that silently returns wrong data? That can run for weeks before anyone notices. By then the damage is everywhere.</p>
<p>I write code that crashes early. If something is wrong, I want to know immediately. Not in a log file nobody reads. Not as a subtle data inconsistency. A loud, obvious failure.</p>
<p>Assert your assumptions. Validate at boundaries. If a function receives data it doesn't expect, panic. Don't try to "handle" it by guessing what the caller meant.</p>
<p>A crash is a gift. It tells you exactly what went wrong, exactly where, exactly when. Silent failures tell you nothing until it's too late.</p>`
    },
    'no-meetings': {
        title: 'Just write it down',
        stage: 'sprout',
        planted: '2024-06',
        tended: '2025-09',
        words: ['building', 'adapt', 'from', 'systems'],
        relatedNotes: ['remote-from-india', 'shipping-fast'],
        content: `<p>Most meetings should be a document.</p>
<p>A meeting takes an hour from five people. That's five hours gone. A document takes 30 minutes to write and 10 minutes each to read. Same information, four hours saved.</p>
<p>I've worked with teams that had no meetings at all. Just shared documents, pull requests, and short messages. We shipped faster than any team I'd been on before.</p>
<p>Writing forces clarity. In a meeting you can wave your hands and say "you know what I mean." In a document you actually have to say what you mean.</p>
<p>When I need a decision, I write a one-page proposal with my recommendation and two alternatives. People read it, comment, and we're done. No scheduling. No "can everyone do Tuesday at 3?"</p>`
    },
    'api-first': {
        title: 'Start with the interface',
        stage: 'sprout',
        planted: '2025-01',
        tended: '2025-12',
        words: ['building', 'systems', 'foundations', 'principles'],
        relatedNotes: ['naming', 'minimal-software'],
        content: `<p>Before I write any implementation, I write the function signature. The API. The interface. Whatever you want to call the boundary between "what it does" and "how it does it."</p>
<p>If the interface is clean, the implementation usually follows. If the interface is awkward, no amount of clever code inside will fix it.</p>
<p>I've thrown away entire implementations and kept the interface unchanged. The callers never knew. That's the point. The interface is the contract. Everything else is negotiable.</p>
<p>Most bad code isn't bad inside functions. It's bad at the boundaries. Functions that take seven parameters. Methods that do three things. APIs that require you to call things in a specific order. Fix the interface and the code fixes itself.</p>`
    },
    'delete-your-code': {
        title: 'Delete it',
        stage: 'evergreen',
        planted: '2024-03',
        tended: '2026-01',
        words: ['minimal', 'dependencies', 'source', 'principles'],
        relatedNotes: ['minimal-software', 'the-100-line-rule'],
        content: `<p>The best commit I made last month was 400 lines of deletions.</p>
<p>There was a feature nobody used. I checked the analytics. Zero hits in 90 days. I deleted it. The codebase got simpler. The tests got faster. One less thing to maintain.</p>
<p>Developers are hoarders. "We might need this later." You won't. And if you do, it's in git. But you won't.</p>
<p>I do a deletion pass every few months. Dead code. Unused imports. Config for features that shipped three versions ago. Comments that describe code that's been rewritten twice since.</p>
<p>Every line you delete is a line that can't have bugs. A line that can't confuse the next person. A line that doesn't slow down your IDE. Deletion is the most underrated refactoring tool.</p>`
    },
    'types-are-docs': {
        title: 'Types are the first draft',
        stage: 'seed',
        planted: '2025-06',
        tended: '2025-12',
        words: ['computation', 'verifiable', 'foundations', 'source'],
        relatedNotes: ['rust-changed-my-brain', 'naming'],
        content: `<p>I write the types before I write the logic.</p>
<p>A type signature is a compressed specification. <code>fn parse(input: &str) -> Result&lt;Version, ParseError&gt;</code> tells you almost everything. It takes a string. It might fail. When it succeeds, you get a Version. When it fails, you know why.</p>
<p>No comment could do that in fewer characters. And unlike comments, the compiler checks types. They can't drift out of date. They can't lie.</p>
<p>TypeScript made me appreciate this. Coming from JavaScript, adding types felt like busywork. Then I stopped having an entire class of bugs. Functions getting called with wrong arguments. Properties accessed on undefined. Type narrowing catching impossible states.</p>
<p>Types won't catch logic bugs. But they catch everything else. That frees my brain to focus on the hard problems.</p>`
    },
    'cache-everything': {
        title: 'Cache it',
        stage: 'sprout',
        planted: '2024-09',
        tended: '2025-10',
        words: ['computation', 'systems', 'execute', 'runtimes'],
        relatedNotes: ['speed-is-a-feature', 'semver-30x-faster'],
        content: `<p>The fastest computation is the one you don't do.</p>
<p>My semver library is fast because it precomputes. My bots are fast because they cache user data. This website is fast because there's nothing to compute at all.</p>
<p>People reach for clever algorithms when a lookup table would do. I've replaced O(n log n) sorts with O(1) hash lookups more times than I can count. Not because I'm smart. Because the data didn't change often enough to justify recomputing.</p>
<p>The trick is knowing when to invalidate. Cache without invalidation is just a bug waiting to happen. I keep caches small, TTLs short, and invalidation explicit. A stale cache is worse than no cache.</p>
<p>When in doubt: compute once, store the result, serve it forever. Recompute only when the input changes.</p>`
    },
    'overnight': {
        title: 'No overnight successes',
        stage: 'sprout',
        planted: '2025-02',
        tended: '2025-12',
        words: ['building', 'learn', 'adapt'],
        relatedNotes: ['seven-years', 'side-projects'],
        content: `<p>My most popular repo has 500 stars. It took four years to get there.</p>
<p>Year one: 12 stars. All from friends. Year two: 40. A few strangers found it. Year three: 150. Someone mentioned it in a blog post. Year four: 500. It showed up on Hacker News for 20 minutes.</p>
<p>From the outside it looks like it blew up overnight. From the inside it was four years of quiet commits, fixing issues nobody reported, and improving docs nobody read yet.</p>
<p>Every "overnight success" I know has a story like this. Years of invisible work, then one day of visibility. The visibility isn't the success. The years are.</p>
<p>Keep shipping. Even when nobody's watching. Especially when nobody's watching.</p>`
    },
    'india': {
        title: 'Building from India',
        stage: 'sprout',
        planted: '2024-08',
        tended: '2025-11',
        words: ['building', 'from', 'adapt', 'learn'],
        relatedNotes: ['remote-from-india', 'seven-years'],
        content: `<p>The Indian tech scene has a reputation problem. Cheap outsourcing. Body shops. "Do the needful."</p>
<p>I ignore all of it. I charge $1,000/day. I turn down work that isn't interesting. I open source everything I can.</p>
<p>The best developers I know are in India. They just don't have the visibility. They're building real systems for real scale, not getting profiled in TechCrunch.</p>
<p>My internet is fine. My hardware is fine. My timezone is an advantage. The only thing that used to be hard was payments, and that's solved now too.</p>
<p>Where you build doesn't matter. What you build does. Ship good work. Let the code speak for itself.</p>`
    },
    'burnout': {
        title: 'Take the break',
        stage: 'seed',
        planted: '2025-04',
        tended: '2025-09',
        words: ['learn', 'adapt', 'building'],
        relatedNotes: ['seven-years', 'side-projects'],
        content: `<p>In 2021 I stopped coding for three months. Didn't touch a keyboard. Didn't think about software. Just existed.</p>
<p>When I came back everything was clearer. Problems that felt impossible before were obvious. Code I'd been stuck on for weeks wrote itself in an afternoon.</p>
<p>The break wasn't wasted time. It was the most productive thing I did that year. My brain needed space to reorganize.</p>
<p>Now I take breaks before I need them. A week off every few months. No guilt. No "just one quick fix." Off means off.</p>
<p>You're not a machine. Machines don't need breaks. You do. Take them.</p>`
    },
    'simplicity-debt': {
        title: 'Complexity is debt',
        stage: 'evergreen',
        planted: '2023-11',
        tended: '2026-01',
        words: ['minimal', 'principles', 'systems', 'dependencies'],
        relatedNotes: ['minimal-software', 'boring-tech'],
        content: `<p>Every abstraction is a loan. You're borrowing simplicity now and paying complexity later.</p>
<p>Sometimes the loan is worth it. A well-placed abstraction saves hours. But most abstractions are premature. You add a factory because you think you'll need four implementations. You end up with one. Now you have a factory with one implementation and everyone has to understand the indirection.</p>
<p>I count abstractions like I count dependencies. Each one needs to justify its existence. If I can't explain why this layer exists in one sentence, I flatten it.</p>
<p>Three lines of duplicated code is better than one abstraction nobody understands. You can always abstract later. You can't easily un-abstract.</p>`
    },
    'git-small': {
        title: 'Tiny commits',
        stage: 'seed',
        planted: '2025-09',
        tended: '2026-01',
        words: ['building', 'source', 'adapt', 'systems'],
        relatedNotes: ['shipping-fast', 'delete-your-code'],
        content: `<p>My average commit is 15 lines. Some are 3. Rarely more than 50.</p>
<p>Each commit does one thing. Rename a variable. Fix a bug. Add a function. Not "refactor auth module." That's five commits pretending to be one.</p>
<p>Small commits make git bisect useful. When a bug appears, you can binary search through commits and find it in minutes. If each commit is 500 lines, bisect tells you "the bug is somewhere in these 500 lines." Thanks for nothing.</p>
<p>Small commits also make code review possible. I can review a 10-line diff in 30 seconds. I can review a 500-line diff in... actually I can't. Nobody can. They just skim and approve.</p>
<p>Write the smallest commit that makes sense on its own. Then write the next one.</p>`
    }
};

// Get notes that reference a word
function getNotesForWord(word) {
    const results = [];
    for (const [id, note] of Object.entries(notesData)) {
        if (note.words.includes(word)) {
            results.push({ id, ...note });
        }
    }
    return results;
}

// Get backlinks: words that mention this word in their blocks but aren't in its related array
function getBacklinks(wordId) {
    const data = wordData[wordId];
    const relatedSet = new Set(data?.related || []);
    const results = [];
    const pattern = new RegExp('\\b' + wordId.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'i');
    for (const [id, w] of Object.entries(wordData)) {
        if (id === wordId || relatedSet.has(id) || SKIP_WORDS.has(id)) continue;
        // Check if this word's related array includes wordId
        if (w.related && w.related.includes(wordId)) {
            results.push(id);
            continue;
        }
        // Check block text/items for mentions
        for (const block of (w.blocks || [])) {
            const texts = [block.text || '', ...(block.items || [])].join(' ');
            if (pattern.test(texts)) {
                results.push(id);
                break;
            }
        }
    }
    return results;
}

// Graph analytics
function computeGraphAnalytics() {
    const words = Object.keys(wordData);
    const n = words.length;
    if (n === 0) return {};

    // Build adjacency list (undirected)
    const adj = {};
    words.forEach(w => { adj[w] = new Set(); });
    words.forEach(w => {
        (wordData[w].related || []).forEach(r => {
            if (wordData[r]) { adj[w].add(r); adj[r].add(w); }
        });
    });

    // Degree centrality
    const degrees = words.map(w => ({ id: w, degree: adj[w].size }));
    degrees.sort((a, b) => b.degree - a.degree);
    const avgDegree = (degrees.reduce((s, d) => s + d.degree, 0) / n).toFixed(1);
    const topDegree = degrees.slice(0, 5);

    // Clustering coefficient
    let totalCC = 0;
    words.forEach(w => {
        const neighbors = [...adj[w]];
        const k = neighbors.length;
        if (k < 2) return;
        let edges = 0;
        for (let i = 0; i < k; i++)
            for (let j = i + 1; j < k; j++)
                if (adj[neighbors[i]].has(neighbors[j])) edges++;
        totalCC += (2 * edges) / (k * (k - 1));
    });
    const avgClustering = (totalCC / n).toFixed(3);

    // Betweenness centrality (Brandes)
    const betweenness = {};
    words.forEach(w => { betweenness[w] = 0; });
    words.forEach(s => {
        const S = [];
        const P = {};
        const sigma = {};
        const d = {};
        words.forEach(w => { P[w] = []; sigma[w] = 0; d[w] = -1; });
        sigma[s] = 1; d[s] = 0;
        const Q = [s];
        while (Q.length) {
            const v = Q.shift();
            S.push(v);
            adj[v].forEach(w => {
                if (d[w] < 0) { Q.push(w); d[w] = d[v] + 1; }
                if (d[w] === d[v] + 1) { sigma[w] += sigma[v]; P[w].push(v); }
            });
        }
        const delta = {};
        words.forEach(w => { delta[w] = 0; });
        while (S.length) {
            const w = S.pop();
            P[w].forEach(v => { delta[v] += (sigma[v] / sigma[w]) * (1 + delta[w]); });
            if (w !== s) betweenness[w] += delta[w];
        }
    });
    // Normalize
    const maxBetween = Math.max(...Object.values(betweenness)) || 1;
    const topBetweenness = Object.entries(betweenness)
        .map(([id, val]) => ({ id, value: (val / maxBetween).toFixed(3) }))
        .sort((a, b) => b.value - a.value)
        .slice(0, 5);

    // Bridge nodes (articulation points via DFS)
    const bridges = [];
    const visited = new Set();
    const disc = {};
    const low = {};
    const parent = {};
    let timer = 0;
    function dfsBridge(u) {
        visited.add(u);
        disc[u] = low[u] = timer++;
        let children = 0;
        adj[u].forEach(v => {
            if (!visited.has(v)) {
                children++;
                parent[v] = u;
                dfsBridge(v);
                low[u] = Math.min(low[u], low[v]);
                if (!parent[u] && children > 1) { if (!bridges.includes(u)) bridges.push(u); }
                if (parent[u] && low[v] >= disc[u]) { if (!bridges.includes(u)) bridges.push(u); }
            } else if (v !== parent[u]) {
                low[u] = Math.min(low[u], disc[v]);
            }
        });
    }
    words.forEach(w => { parent[w] = undefined; });
    words.forEach(w => { if (!visited.has(w)) dfsBridge(w); });

    return { avgDegree, topDegree, avgClustering, topBetweenness, bridges, totalEdges: degrees.reduce((s, d) => s + d.degree, 0) / 2 };
}

// Community detection (Label Propagation)
function detectCommunities() {
    const words = Object.keys(wordData);
    const labels = {};
    words.forEach((w, i) => { labels[w] = i; });

    const adj = {};
    words.forEach(w => { adj[w] = []; });
    words.forEach(w => {
        (wordData[w].related || []).forEach(r => {
            if (wordData[r]) {
                if (!adj[w].includes(r)) adj[w].push(r);
                if (!adj[r].includes(w)) adj[r].push(w);
            }
        });
    });

    for (let iter = 0; iter < 50; iter++) {
        let changed = false;
        const shuffled = [...words].sort(() => Math.random() - 0.5);
        for (const w of shuffled) {
            const neighbors = adj[w];
            if (neighbors.length === 0) continue;
            const freq = {};
            neighbors.forEach(n => { freq[labels[n]] = (freq[labels[n]] || 0) + 1; });
            let maxFreq = 0, maxLabel = labels[w];
            for (const [l, f] of Object.entries(freq)) {
                if (f > maxFreq) { maxFreq = f; maxLabel = Number(l); }
            }
            if (labels[w] !== maxLabel) { labels[w] = maxLabel; changed = true; }
        }
        if (!changed) break;
    }

    // Group by label
    const communities = {};
    words.forEach(w => {
        const l = labels[w];
        if (!communities[l]) communities[l] = [];
        communities[l].push(w);
    });

    // Name each community by most-connected member
    return Object.values(communities).map(members => {
        members.sort((a, b) => (wordData[b].related?.length || 0) - (wordData[a].related?.length || 0));
        return { name: members[0], members };
    }).sort((a, b) => b.members.length - a.members.length);
}

// Home component
const Home = {
    template: `
        <div class="container">
            <div class="main">
                <p class="statement">
                    <router-link to="/words/building" class="word">Building</router-link>&nbsp;
                    <router-link to="/words/at" class="word">at</router-link>&nbsp;
                    <router-link to="/words/the" class="word">the</router-link>&nbsp;
                    <router-link to="/words/intersection" class="word">intersection</router-link>&nbsp;
                    <router-link to="/words/of" class="word">of</router-link>&nbsp;
                    <router-link to="/words/computation" class="word">computation</router-link><span class="punctuation">, </span>
                    <router-link to="/words/cognition" class="word">cognition</router-link><span class="punctuation">, </span>
                    <router-link to="/words/and" class="word">and</router-link>&nbsp;
                    <router-link to="/words/first" class="word">first</router-link>&nbsp;
                    <router-link to="/words/principles" class="word">principles</router-link><span class="punctuation">. </span>
                    <router-link to="/words/systems" class="word">Systems</router-link>&nbsp;
                    <router-link to="/words/that" class="word">that</router-link>&nbsp;
                    <router-link to="/words/learn" class="word">learn</router-link><span class="punctuation">, </span>
                    <router-link to="/words/adapt" class="word">adapt</router-link><span class="punctuation">, </span>
                    <router-link to="/words/and" class="word">and</router-link>&nbsp;
                    <router-link to="/words/reason" class="word">reason</router-link>&nbsp;
                    <router-link to="/words/not" class="word">not</router-link>&nbsp;
                    <router-link to="/words/just" class="word">just</router-link>&nbsp;
                    <router-link to="/words/execute" class="word">execute</router-link><span class="punctuation">. </span>
                    <router-link to="/words/verifiable" class="word">Verifiable</router-link>&nbsp;
                    <router-link to="/words/foundations" class="word">foundations</router-link><span class="punctuation">. </span>
                    <router-link to="/words/massively" class="word">Massively</router-link>&nbsp;
                    <router-link to="/words/parallel" class="word">parallel</router-link>&nbsp;
                    <router-link to="/words/runtimes" class="word">runtimes</router-link><span class="punctuation">. </span>
                    <router-link to="/words/everything" class="word">Everything</router-link>&nbsp;
                    <router-link to="/words/minimal" class="word">minimal</router-link><span class="punctuation">: </span>
                    <router-link to="/words/small" class="word">small</router-link>&nbsp;
                    <router-link to="/words/footprint" class="word">footprint</router-link><span class="punctuation">, </span>
                    <router-link to="/words/zero" class="word">zero</router-link>&nbsp;
                    <router-link to="/words/dependencies" class="word">dependencies</router-link>&nbsp;
                    <router-link to="/words/where" class="word">where</router-link>&nbsp;
                    <router-link to="/words/possible" class="word">possible</router-link><span class="punctuation">, </span>
                    <router-link to="/words/auditable" class="word">auditable</router-link>&nbsp;
                    <router-link to="/words/from" class="word">from</router-link>&nbsp;
                    <router-link to="/words/source" class="word">source</router-link><span class="punctuation">.</span>
                </p>
            </div>
            <div class="footer">
                <span>lulzx</span>
                <div class="footer-links">
                    <a href="https://github.com/lulzx">github</a>
                    <a href="mailto:hello@lulzx.dev">email</a>
                    <router-link to="/garden">garden map</router-link>
                    <router-link to="/timeline">timeline</router-link>
                    <a href="#" @click.prevent="wander">wander</a>
                    <a href="#" @click.prevent="toggleDark">dark/light</a>
                </div>
            </div>
        </div>
    `,
    methods: {
        wander() {
            const words = ALL_WORDS();
            const word = words[Math.floor(Math.random() * words.length)];
            this.$router.push('/words/' + word);
        },
        toggleDark() { toggleDarkMode(); }
    }
};

// Word page component
const WordPage = {
    template: `
        <div class="word-page">
            <div class="word-header">
                <div class="word-header-left">
                    <router-link to="/" class="back">\u2190 back</router-link>
                    <div class="breadcrumbs" v-if="trail.length > 0">
                        <span class="sep">/</span>
                        <template v-for="(crumb, i) in trail" :key="crumb">
                            <router-link :to="'/words/' + crumb">{{ crumb }}</router-link>
                            <span class="sep" v-if="i < trail.length - 1">/</span>
                        </template>
                    </div>
                </div>
                <span style="font-size: 0.875rem;">lulzx</span>
            </div>
            <div class="word-title-section">
                <div class="word-title">{{ wordId }}</div>
                <span v-if="data" class="stage-badge" :class="'stage-' + data.stage">{{ data.stage }}</span>
            </div>
            <div class="word-meta" v-if="data && data.planted">
                <span>planted {{ timeAgo(data.planted) }}</span>
                <span>tended {{ timeAgo(data.tended) }}</span>
            </div>
            <div class="word-content" :key="wordId">
                <div v-for="(block, index) in blocks" :key="index"
                     class="block"
                     :class="{ 'block-inverted': block.stat || block.check, 'block-zero': block.zero }"
                     v-scroll-reveal="{ delay: index * 0.05 }">
                    <div v-if="block.stat" class="stat">{{ block.stat }}</div>
                    <div v-if="block.zero" class="zero">0</div>
                    <div v-if="block.check" style="font-size: 4rem; margin-bottom: 1rem;">{{ block.check }}</div>
                    <h2 v-if="block.label">{{ block.label }}</h2>
                    <h2 v-else>{{ block.title }}</h2>
                    <p v-if="block.text" v-html="linkifyText(block.text)"></p>
                    <ul v-if="block.items">
                        <li v-for="item in block.items" :key="item" v-html="linkifyText(item)"></li>
                    </ul>
                </div>
            </div>
            <div class="connections-section" v-if="related.length > 0">
                <div class="section-title">Connections</div>
                <div class="chips">
                    <router-link v-for="r in related" :key="r" :to="'/words/' + r" class="chip">{{ r }}</router-link>
                </div>
            </div>
            <div class="notes-section" v-if="notes.length > 0">
                <div class="section-title">Notes</div>
                <router-link v-for="note in notes" :key="note.id" :to="'/notes/' + note.id" class="note-link">
                    <span class="note-link-title">{{ note.title }}</span>
                    <span class="note-link-stage">{{ note.stage }}</span>
                </router-link>
            </div>
            <div class="connections-section" v-if="backlinks.length > 0">
                <div class="section-title">Backlinks</div>
                <div class="chips">
                    <router-link v-for="b in backlinks" :key="b" :to="'/words/' + b" class="chip">{{ b }}</router-link>
                </div>
            </div>
            <div class="next-section" v-if="unvisited.length > 0">
                <div class="section-title">Up Next</div>
                <div class="chips">
                    <router-link v-for="u in unvisited" :key="u.type + u.id" :to="u.type === 'word' ? '/words/' + u.id : '/notes/' + u.id" class="chip-unvisited">{{ u.label }}</router-link>
                </div>
            </div>
            <div class="wander-section">
                <a href="#" class="wander-btn" @click.prevent="toggleDark">dark/light</a>
                <button class="wander-btn" @click="wander">\u2192 wander to a random word</button>
            </div>
        </div>
    `,
    computed: {
        wordId() {
            return this.$route.params.word;
        },
        data() {
            return wordData[this.wordId];
        },
        blocks() {
            return this.data?.blocks || [{ title: "Not Found", text: "This word has no content yet." }];
        },
        related() {
            return this.data?.related || [];
        },
        backlinks() {
            return getBacklinks(this.wordId);
        },
        notes() {
            return getNotesForWord(this.wordId);
        },
        trail() {
            const t = getTrail().filter(w => w !== this.wordId);
            return t.slice(-3);
        },
        unvisited() {
            return getUnvisitedConnections(this.wordId);
        }
    },
    methods: {
        timeAgo,
        linkifyText(text) {
            if (!text) return '';
            const wordKeys = ALL_WORDS().filter(w => !SKIP_WORDS.has(w));
            // Sort by length descending so longer words match first
            wordKeys.sort((a, b) => b.length - a.length);
            // Build regex that matches whole words only
            const pattern = new RegExp('\\b(' + wordKeys.map(w => w.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|') + ')\\b', 'gi');
            return text.replace(pattern, (match) => {
                const lower = match.toLowerCase();
                if (lower === this.wordId) return match; // Don't link to self
                if (wordData[lower]) {
                    return '<a href="/words/' + lower + '" class="inline-word-link" onclick="event.preventDefault(); window.__gardenRouter.push(\'/words/' + lower + '\')">' + match + '</a>';
                }
                return match;
            });
        },
        wander() {
            const words = ALL_WORDS().filter(w => w !== this.wordId);
            const word = words[Math.floor(Math.random() * words.length)];
            this.$router.push('/words/' + word);
        },
        toggleDark() { toggleDarkMode(); }
    },
    watch: {
        wordId: {
            handler(val) {
                if (val && wordData[val]) {
                    addToTrail(val);
                    markVisited('word', val);
                }
            },
            immediate: true
        }
    }
};

// Note page component
const NotePage = {
    template: `
        <div class="note-page" v-if="note">
            <div class="word-header">
                <router-link to="/" class="back">\u2190 back</router-link>
                <span style="font-size: 0.875rem;">lulzx</span>
            </div>
            <div class="note-header">
                <div class="note-title">{{ note.title }}</div>
                <div class="note-meta">
                    <span class="stage-badge" :class="'stage-' + note.stage">{{ note.stage }}</span>
                    <span>planted {{ timeAgo(note.planted) }}</span>
                    <span>tended {{ timeAgo(note.tended) }}</span>
                    <span>{{ readingTime(note.content) }} min read</span>
                </div>
            </div>
            <div class="note-body" v-html="note.content"></div>
            <div class="note-connections" v-if="note.words && note.words.length">
                <div class="section-title">Connected Words</div>
                <div class="chips">
                    <router-link v-for="w in note.words" :key="w" :to="'/words/' + w" class="chip">{{ w }}</router-link>
                </div>
            </div>
            <div class="note-related" v-if="note.relatedNotes && note.relatedNotes.length">
                <div class="section-title">Related Notes</div>
                <router-link v-for="rn in note.relatedNotes" :key="rn" :to="'/notes/' + rn" class="note-link">
                    <span class="note-link-title">{{ getNoteTitle(rn) }}</span>
                </router-link>
            </div>
            <div class="next-section" v-if="unvisitedConns.length > 0">
                <div class="section-title">Up Next</div>
                <div class="chips">
                    <router-link v-for="u in unvisitedConns" :key="u.type + u.id" :to="u.type === 'word' ? '/words/' + u.id : '/notes/' + u.id" class="chip-unvisited">{{ u.label }}</router-link>
                </div>
            </div>
            <div class="wander-section">
                <a href="#" class="wander-btn" @click.prevent="toggleDark">dark/light</a>
                <button class="wander-btn" @click="wander">\u2192 wander to a random word</button>
            </div>
        </div>
        <div class="word-page" v-else>
            <div class="word-header">
                <router-link to="/" class="back">\u2190 back</router-link>
                <span style="font-size: 0.875rem;">lulzx</span>
            </div>
            <div class="word-title-section">
                <div class="word-title">404</div>
            </div>
            <div class="word-content">
                <div class="block"><h2>Not Found</h2><p>This note doesn't exist. <router-link to="/garden" style="color:var(--text);text-decoration: underline;">Browse the garden</router-link>.</p></div>
            </div>
        </div>
    `,
    computed: {
        noteId() {
            return this.$route.params.noteId;
        },
        note() {
            return notesData[this.noteId];
        },
        unvisitedConns() {
            if (!this.note) return [];
            const conns = [];
            (this.note.words || []).forEach(w => {
                if (!isVisited('word', w)) conns.push({ type: 'word', id: w, label: w });
            });
            (this.note.relatedNotes || []).forEach(rn => {
                if (!isVisited('note', rn)) conns.push({ type: 'note', id: rn, label: notesData[rn]?.title || rn });
            });
            return conns.slice(0, 3);
        }
    },
    methods: {
        timeAgo,
        readingTime,
        getNoteTitle(id) {
            return notesData[id]?.title || id;
        },
        wander() {
            const words = ALL_WORDS();
            const word = words[Math.floor(Math.random() * words.length)];
            this.$router.push('/words/' + word);
        },
        toggleDark() { toggleDarkMode(); },
        highlightSearchQuery() {
            const q = this.$route.query.q;
            const el = this.$el?.querySelector('.note-body');
            if (!el) return;
            // Remove old highlights
            el.querySelectorAll('.search-highlight').forEach(mark => {
                const parent = mark.parentNode;
                parent.replaceChild(document.createTextNode(mark.textContent), mark);
                parent.normalize();
            });
            if (!q) return;
            const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT);
            const nodes = [];
            while (walker.nextNode()) nodes.push(walker.currentNode);
            const lower = q.toLowerCase();
            let firstMatch = null;
            nodes.forEach(node => {
                const text = node.textContent;
                const idx = text.toLowerCase().indexOf(lower);
                if (idx === -1) return;
                const before = text.slice(0, idx);
                const match = text.slice(idx, idx + q.length);
                const after = text.slice(idx + q.length);
                const mark = document.createElement('mark');
                mark.className = 'search-highlight';
                mark.textContent = match;
                const parent = node.parentNode;
                if (before) parent.insertBefore(document.createTextNode(before), node);
                parent.insertBefore(mark, node);
                if (after) parent.insertBefore(document.createTextNode(after), node);
                parent.removeChild(node);
                if (!firstMatch) firstMatch = mark;
            });
            if (firstMatch) firstMatch.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    },
    mounted() {
        if (this.noteId && notesData[this.noteId]) markVisited('note', this.noteId);
        this.$nextTick(() => this.highlightSearchQuery());
    },
    watch: {
        noteId(val) {
            if (val && notesData[val]) markVisited('note', val);
        },
        '$route.query.q'() {
            this.$nextTick(() => this.highlightSearchQuery());
        }
    },
    updated() {
        this.$nextTick(() => this.highlightSearchQuery());
    },
    _highlightApplied: false
};

// Garden map component
const GardenMap = {
    template: `
        <div class="garden-page">
            <div class="word-header">
                <router-link to="/" class="back">\u2190 back</router-link>
                <span style="font-size: 0.875rem;">lulzx</span>
            </div>
            <div class="garden-header">
                <div class="garden-title">Garden Map</div>
                <div class="garden-subtitle">{{ totalWords }} words, {{ totalNotes }} notes. An interconnected web of ideas at various stages of growth.</div>
                <div style="margin-top: 1.5rem;">
                    <div class="discovery-score">{{ discoveryScore }}%</div>
                    <div class="stat-label">discovered</div>
                    <div class="progress-bar"><div class="progress-fill" :style="{ width: discoveryScore + '%' }"></div></div>
                    <div class="discovery-detail">{{ visitedCount.words }} of {{ totalWords }} words, {{ visitedCount.notes }} of {{ totalNotes }} notes explored</div>
                </div>
            </div>
            <div class="garden-filters">
                <button class="filter-btn" :class="{ active: filter === 'all' }" @click="filter = 'all'">All</button>
                <button class="filter-btn" :class="{ active: filter === 'evergreen' }" @click="filter = 'evergreen'">Evergreen</button>
                <button class="filter-btn" :class="{ active: filter === 'sprout' }" @click="filter = 'sprout'">Sprout</button>
                <button class="filter-btn" :class="{ active: filter === 'seed' }" @click="filter = 'seed'">Seed</button>
                <button class="view-toggle" :class="{ active: viewMode === 'topics' }" @click="viewMode = viewMode === 'grid' ? 'topics' : 'grid'">{{ viewMode === 'grid' ? 'Topics' : 'Grid' }}</button>
            </div>
            <div class="graph-container" ref="graphContainer">
                <canvas ref="graphCanvas"></canvas>
                <div class="graph-tooltip" v-if="tooltip.visible" :style="{ top: tooltip.y + 'px', left: tooltip.x + 'px' }">
                    <strong>{{ tooltip.name }}</strong> <span style="font-size:0.65rem;text-transform:uppercase;letter-spacing:0.08em;opacity:0.6;margin-left:0.5rem;">{{ tooltip.stage }}</span>
                </div>
                <div class="graph-controls">
                    <button @click="resetZoom">Reset Zoom</button>
                    <button :class="{ active: pathMode }" @click="togglePathMode">{{ pathMode ? 'Cancel Path' : 'Find Path' }}</button>
                </div>
                <div class="path-instruction" v-if="pathMode && pathNodes.length < 2">Click {{ pathNodes.length === 0 ? 'start' : 'end' }} node</div>
            </div>
            <div class="garden-section" v-if="analytics">
                <div class="garden-section-title">Graph Analytics</div>
                <div class="analytics-grid">
                    <div class="block block-inverted">
                        <div class="stat">{{ analytics.avgDegree }}</div>
                        <div class="stat-label">Avg Connections</div>
                    </div>
                    <div class="block block-inverted">
                        <div class="stat">{{ analytics.totalEdges }}</div>
                        <div class="stat-label">Total Edges</div>
                    </div>
                    <div class="block block-inverted">
                        <div class="stat">{{ analytics.avgClustering }}</div>
                        <div class="stat-label">Clustering Coeff</div>
                    </div>
                    <div class="block">
                        <h2>Most Connected</h2>
                        <ul>
                            <li v-for="d in analytics.topDegree" :key="d.id">{{ d.id }} ({{ d.degree }})</li>
                        </ul>
                    </div>
                    <div class="block">
                        <h2>Highest Betweenness</h2>
                        <ul>
                            <li v-for="b in analytics.topBetweenness" :key="b.id">{{ b.id }} ({{ b.value }})</li>
                        </ul>
                    </div>
                    <div class="block" v-if="analytics.bridges.length > 0">
                        <h2>Bridge Nodes</h2>
                        <ul>
                            <li v-for="b in analytics.bridges" :key="b">{{ b }}</li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="garden-section" v-if="viewMode === 'topics'">
                <div class="garden-section-title">Topics ({{ communities.length }} clusters)</div>
                <div v-for="c in communities" :key="c.name" class="topic-cluster">
                    <div class="topic-header">
                        <span class="topic-name">{{ c.name }}</span>
                        <span class="topic-count">{{ c.members.length }} words</span>
                    </div>
                    <div class="chips">
                        <router-link v-for="m in c.members" :key="m" :to="'/words/' + m" class="chip">{{ m }}</router-link>
                    </div>
                </div>
            </div>
            <div class="garden-section" v-if="viewMode === 'grid'">
                <div class="garden-section-title">Words ({{ filteredWords.length }})</div>
                <div class="garden-grid">
                    <router-link v-for="(w, i) in filteredWords" :key="w.id" :to="'/words/' + w.id" class="garden-card" v-scroll-reveal="{ delay: i * 0.02 }">
                        <div class="garden-card-name">{{ w.id }}</div>
                        <div class="garden-card-meta">
                            <span><span class="stage-dot" :class="'stage-dot-' + w.stage"></span> {{ w.stage }}</span>
                            <span>{{ w.connections }} links</span>
                        </div>
                    </router-link>
                </div>
            </div>
            <div class="garden-section">
                <div class="garden-section-title">Notes ({{ filteredNotes.length }})</div>
                <div class="garden-notes-grid">
                    <router-link v-for="(n, ni) in filteredNotes" :key="n.id" :to="'/notes/' + n.id" class="garden-note-card" v-scroll-reveal="{ delay: ni * 0.03 }">
                        <div class="garden-note-title">{{ n.title }}</div>
                        <div class="garden-note-meta">
                            <span><span class="stage-dot" :class="'stage-dot-' + n.stage"></span> {{ n.stage }}</span>
                            <span>{{ n.wordCount }} words</span>
                        </div>
                    </router-link>
                </div>
            </div>
            <div class="wander-section">
                <router-link to="/timeline" class="wander-btn">timeline</router-link>
                <a href="#" class="wander-btn" @click.prevent="toggleDark">dark/light</a>
                <button class="wander-btn" @click="wander">\u2192 wander to a random word</button>
            </div>
        </div>
    `,
    data() {
        return {
            filter: 'all',
            viewMode: 'grid',
            tooltip: { visible: false, x: 0, y: 0, name: '', stage: '' },
            graphNodes: [],
            graphEdges: [],
            hoveredNode: null,
            _raf: null,
            communities: [],
            analytics: null,
            transform: { x: 0, y: 0, scale: 1 },
            dragState: null,
            pathMode: false,
            pathNodes: [],
            pathEdges: []
        };
    },
    computed: {
        totalWords() { return Object.keys(wordData).length; },
        totalNotes() { return Object.keys(notesData).length; },
        discoveryScore() { return getDiscoveryScore(); },
        visitedCount() { const v = getVisited(); return { words: v.words.length, notes: v.notes.length }; },
        allWords() {
            return Object.entries(wordData).map(([id, d]) => ({
                id,
                stage: d.stage,
                connections: (d.related || []).length
            })).sort((a, b) => {
                const order = { evergreen: 0, sprout: 1, seed: 2 };
                return (order[a.stage] - order[b.stage]) || a.id.localeCompare(b.id);
            });
        },
        filteredWords() {
            if (this.filter === 'all') return this.allWords;
            return this.allWords.filter(w => w.stage === this.filter);
        },
        allNotes() {
            return Object.entries(notesData).map(([id, n]) => ({
                id,
                title: n.title,
                stage: n.stage,
                wordCount: n.content.replace(/<[^>]*>/g, '').split(/\s+/).length
            }));
        },
        filteredNotes() {
            if (this.filter === 'all') return this.allNotes;
            return this.allNotes.filter(n => n.stage === this.filter);
        }
    },
    methods: {
        wander() {
            const words = ALL_WORDS();
            const word = words[Math.floor(Math.random() * words.length)];
            this.$router.push('/words/' + word);
        },
        toggleDark() { toggleDarkMode(); },
        resetZoom() {
            this.transform = { x: 0, y: 0, scale: 1 };
            if (this._ctx) this.renderGraph(this._ctx, this._W, this._H);
        },
        togglePathMode() {
            this.pathMode = !this.pathMode;
            this.pathNodes = [];
            this.pathEdges = [];
            if (this._ctx) this.renderGraph(this._ctx, this._W, this._H);
        },
        findShortestPath(startId, endId) {
            const nodes = this.graphNodes;
            const edges = this.graphEdges;
            const adj = {};
            nodes.forEach(n => { adj[n.id] = []; });
            edges.forEach(e => {
                adj[e.source.id].push(e.target.id);
                adj[e.target.id].push(e.source.id);
            });
            const visited = new Set([startId]);
            const parent = {};
            const queue = [startId];
            while (queue.length) {
                const v = queue.shift();
                if (v === endId) break;
                for (const w of (adj[v] || [])) {
                    if (!visited.has(w)) { visited.add(w); parent[w] = v; queue.push(w); }
                }
            }
            if (!parent[endId] && startId !== endId) return [];
            const path = [endId];
            let cur = endId;
            while (cur !== startId) { cur = parent[cur]; if (!cur) return []; path.unshift(cur); }
            return path;
        },
        screenToWorld(e) {
            const canvas = this.$refs.graphCanvas;
            const rect = canvas.getBoundingClientRect();
            const sx = e.clientX - rect.left;
            const sy = e.clientY - rect.top;
            return {
                x: (sx - this.transform.x) / this.transform.scale,
                y: (sy - this.transform.y) / this.transform.scale
            };
        },
        initGraph() {
            const canvas = this.$refs.graphCanvas;
            const container = this.$refs.graphContainer;
            if (!canvas || !container) return;

            const dpr = window.devicePixelRatio || 1;
            const rect = container.getBoundingClientRect();
            const W = rect.width;
            const H = rect.height;
            canvas.width = W * dpr;
            canvas.height = H * dpr;
            canvas.style.width = W + 'px';
            canvas.style.height = H + 'px';
            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);

            // Build nodes
            const nodeMap = {};
            const nodes = [];
            const edges = [];

            Object.entries(wordData).forEach(([id, d]) => {
                const connCount = (d.related || []).length;
                const node = {
                    id, type: 'word', stage: d.stage,
                    x: W/2 + (Math.random() - 0.5) * W * 0.6,
                    y: H/2 + (Math.random() - 0.5) * H * 0.6,
                    vx: 0, vy: 0,
                    r: Math.max(4, Math.min(12, 3 + connCount * 1.2)),
                    label: id, path: '/words/' + id
                };
                nodes.push(node);
                nodeMap[id] = node;
            });

            Object.entries(notesData).forEach(([id, n]) => {
                const node = {
                    id: 'note:' + id, type: 'note', stage: n.stage,
                    x: W/2 + (Math.random() - 0.5) * W * 0.6,
                    y: H/2 + (Math.random() - 0.5) * H * 0.6,
                    vx: 0, vy: 0,
                    r: 4, label: n.title, path: '/notes/' + id
                };
                nodes.push(node);
                nodeMap['note:' + id] = node;
            });

            // Build edges (deduplicated)
            const edgeSet = new Set();
            Object.entries(wordData).forEach(([id, d]) => {
                (d.related || []).forEach(r => {
                    if (wordData[r]) {
                        const key = [id, r].sort().join('|');
                        if (!edgeSet.has(key)) { edgeSet.add(key); edges.push({ source: nodeMap[id], target: nodeMap[r] }); }
                    }
                });
            });
            Object.entries(notesData).forEach(([id, n]) => {
                (n.words || []).forEach(w => {
                    if (nodeMap[w]) {
                        edges.push({ source: nodeMap['note:' + id], target: nodeMap[w] });
                    }
                });
            });

            this.graphNodes = nodes;
            this.graphEdges = edges;

            // Fruchterman-Reingold
            const area = W * H;
            const k = Math.sqrt(area / nodes.length) * 0.85;
            let temp = W / 10;
            const cooling = 0.95;
            let iteration = 0;
            const maxIter = 300;

            const simulate = () => {
                if (iteration >= maxIter) {
                    this.renderGraph(ctx, W, H);
                    return;
                }
                // Repulsive forces
                for (let i = 0; i < nodes.length; i++) {
                    nodes[i].vx = 0;
                    nodes[i].vy = 0;
                    for (let j = 0; j < nodes.length; j++) {
                        if (i === j) continue;
                        let dx = nodes[i].x - nodes[j].x;
                        let dy = nodes[i].y - nodes[j].y;
                        let dist = Math.sqrt(dx * dx + dy * dy) || 0.01;
                        let force = (k * k) / dist;
                        nodes[i].vx += (dx / dist) * force;
                        nodes[i].vy += (dy / dist) * force;
                    }
                }
                // Attractive forces
                for (const e of edges) {
                    let dx = e.source.x - e.target.x;
                    let dy = e.source.y - e.target.y;
                    let dist = Math.sqrt(dx * dx + dy * dy) || 0.01;
                    let force = (dist * dist) / k;
                    let fx = (dx / dist) * force;
                    let fy = (dy / dist) * force;
                    e.source.vx -= fx;
                    e.source.vy -= fy;
                    e.target.vx += fx;
                    e.target.vy += fy;
                }
                // Apply with temperature
                for (const n of nodes) {
                    let dist = Math.sqrt(n.vx * n.vx + n.vy * n.vy) || 0.01;
                    n.x += (n.vx / dist) * Math.min(dist, temp);
                    n.y += (n.vy / dist) * Math.min(dist, temp);
                    // Keep in bounds
                    const pad = 20;
                    n.x = Math.max(pad, Math.min(W - pad, n.x));
                    n.y = Math.max(pad, Math.min(H - pad, n.y));
                }
                temp *= cooling;
                iteration++;
                this.renderGraph(ctx, W, H);
                this._raf = requestAnimationFrame(simulate);
            };

            this._raf = requestAnimationFrame(simulate);
            this._ctx = ctx;
            this._W = W;
            this._H = H;

            // Assign community IDs for rendering
            const communityMap = {};
            this.communities.forEach((c, ci) => {
                c.members.forEach(m => { communityMap[m] = ci; });
            });
            nodes.forEach(n => { n.community = communityMap[n.id] ?? -1; });

            // Mouse events with zoom/pan/drag
            const getNode = (mx, my) => {
                const wx = (mx - this.transform.x) / this.transform.scale;
                const wy = (my - this.transform.y) / this.transform.scale;
                for (let i = nodes.length - 1; i >= 0; i--) {
                    const n = nodes[i];
                    const dx = wx - n.x, dy = wy - n.y;
                    const hitR = n.r + 3;
                    if (dx * dx + dy * dy <= hitR * hitR) return n;
                }
                return null;
            };

            this._onWheel = (e) => {
                e.preventDefault();
                const r = canvas.getBoundingClientRect();
                const mx = e.clientX - r.left;
                const my = e.clientY - r.top;
                const zoom = e.deltaY < 0 ? 1.1 : 0.9;
                const newScale = Math.max(0.3, Math.min(5, this.transform.scale * zoom));
                const ratio = newScale / this.transform.scale;
                this.transform.x = mx - (mx - this.transform.x) * ratio;
                this.transform.y = my - (my - this.transform.y) * ratio;
                this.transform.scale = newScale;
                this.renderGraph(this._ctx, this._W, this._H);
            };

            this._onMouseDown = (e) => {
                const r = canvas.getBoundingClientRect();
                const mx = e.clientX - r.left;
                const my = e.clientY - r.top;
                const node = getNode(mx, my);
                if (node) {
                    this.dragState = { node, startX: node.x, startY: node.y, mouseStartX: mx, mouseStartY: my, moved: false };
                } else {
                    this.dragState = { pan: true, startX: this.transform.x, startY: this.transform.y, mouseStartX: mx, mouseStartY: my, moved: false };
                }
            };

            this._onMouseMove = (e) => {
                const r = canvas.getBoundingClientRect();
                const mx = e.clientX - r.left;
                const my = e.clientY - r.top;

                if (this.dragState) {
                    const dx = mx - this.dragState.mouseStartX;
                    const dy = my - this.dragState.mouseStartY;
                    if (Math.abs(dx) > 2 || Math.abs(dy) > 2) this.dragState.moved = true;
                    if (this.dragState.pan) {
                        this.transform.x = this.dragState.startX + dx;
                        this.transform.y = this.dragState.startY + dy;
                    } else if (this.dragState.node) {
                        this.dragState.node.x = this.dragState.startX + dx / this.transform.scale;
                        this.dragState.node.y = this.dragState.startY + dy / this.transform.scale;
                    }
                    this.renderGraph(this._ctx, this._W, this._H);
                    return;
                }

                const node = getNode(mx, my);
                this.hoveredNode = node;
                canvas.style.cursor = node ? 'pointer' : (this.pathMode ? 'crosshair' : 'grab');
                if (node) {
                    this.tooltip = { visible: true, x: mx + 12, y: my - 10, name: node.label, stage: node.stage };
                } else {
                    this.tooltip.visible = false;
                }
                this.renderGraph(this._ctx, this._W, this._H);
            };

            this._onMouseUp = (e) => {
                const wasDrag = this.dragState?.moved;
                this.dragState = null;
                if (wasDrag) return;

                const r = canvas.getBoundingClientRect();
                const mx = e.clientX - r.left;
                const my = e.clientY - r.top;
                const node = getNode(mx, my);
                if (!node) return;

                if (this.pathMode) {
                    this.pathNodes.push(node.id);
                    if (this.pathNodes.length === 2) {
                        const path = this.findShortestPath(this.pathNodes[0], this.pathNodes[1]);
                        this.pathEdges = path;
                        this.renderGraph(this._ctx, this._W, this._H);
                    }
                } else {
                    this.$router.push(node.path);
                }
            };

            this._onMouseLeave = () => {
                this.dragState = null;
                this.hoveredNode = null;
                this.tooltip.visible = false;
                this.renderGraph(this._ctx, this._W, this._H);
            };

            // Touch events for mobile
            let lastTouchDist = 0;
            this._onTouchStart = (e) => {
                if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    lastTouchDist = Math.sqrt(dx * dx + dy * dy);
                } else if (e.touches.length === 1) {
                    const r = canvas.getBoundingClientRect();
                    const mx = e.touches[0].clientX - r.left;
                    const my = e.touches[0].clientY - r.top;
                    this.dragState = { pan: true, startX: this.transform.x, startY: this.transform.y, mouseStartX: mx, mouseStartY: my, moved: false };
                }
            };
            this._onTouchMove = (e) => {
                e.preventDefault();
                if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (lastTouchDist > 0) {
                        const zoom = dist / lastTouchDist;
                        const newScale = Math.max(0.3, Math.min(5, this.transform.scale * zoom));
                        this.transform.scale = newScale;
                        this.renderGraph(this._ctx, this._W, this._H);
                    }
                    lastTouchDist = dist;
                } else if (e.touches.length === 1 && this.dragState?.pan) {
                    const r = canvas.getBoundingClientRect();
                    const mx = e.touches[0].clientX - r.left;
                    const my = e.touches[0].clientY - r.top;
                    this.transform.x = this.dragState.startX + (mx - this.dragState.mouseStartX);
                    this.transform.y = this.dragState.startY + (my - this.dragState.mouseStartY);
                    this.renderGraph(this._ctx, this._W, this._H);
                }
            };
            this._onTouchEnd = () => { this.dragState = null; lastTouchDist = 0; };

            canvas.addEventListener('wheel', this._onWheel, { passive: false });
            canvas.addEventListener('mousedown', this._onMouseDown);
            canvas.addEventListener('mousemove', this._onMouseMove);
            canvas.addEventListener('mouseup', this._onMouseUp);
            canvas.addEventListener('mouseleave', this._onMouseLeave);
            canvas.addEventListener('touchstart', this._onTouchStart, { passive: false });
            canvas.addEventListener('touchmove', this._onTouchMove, { passive: false });
            canvas.addEventListener('touchend', this._onTouchEnd);
        },
        renderGraph(ctx, W, H) {
            const nodes = this.graphNodes;
            const edges = this.graphEdges;
            const hovered = this.hoveredNode;
            const filter = this.filter;
            const scale = this.transform.scale;
            const tx = this.transform.x;
            const ty = this.transform.y;
            const styles = getComputedStyle(document.documentElement);
            const textColor = styles.getPropertyValue('--text').trim() || '#000';
            const borderColor = styles.getPropertyValue('--border').trim() || '#000';
            const bgColor = styles.getPropertyValue('--bg').trim() || '#fff';
            const subtleColor = styles.getPropertyValue('--gray-subtle').trim() || '#e5e5e5';

            ctx.clearRect(0, 0, W, H);
            ctx.save();
            ctx.translate(tx, ty);
            ctx.scale(scale, scale);

            // Path edge set
            const pathSet = new Set();
            const pathNodeSet = new Set();
            if (this.pathEdges.length > 1) {
                for (let i = 0; i < this.pathEdges.length; i++) {
                    pathNodeSet.add(this.pathEdges[i]);
                    if (i < this.pathEdges.length - 1) {
                        pathSet.add([this.pathEdges[i], this.pathEdges[i+1]].sort().join('|'));
                    }
                }
            }

            // Connected set for hover highlight
            const connectedIds = new Set();
            if (hovered) {
                connectedIds.add(hovered.id);
                for (const e of edges) {
                    if (e.source === hovered) connectedIds.add(e.target.id);
                    if (e.target === hovered) connectedIds.add(e.source.id);
                }
            }

            // Draw edges
            for (const e of edges) {
                const connected = hovered && (connectedIds.has(e.source.id) && connectedIds.has(e.target.id));
                const isPath = pathSet.has([e.source.id, e.target.id].sort().join('|'));
                ctx.beginPath();
                ctx.moveTo(e.source.x, e.source.y);
                ctx.lineTo(e.target.x, e.target.y);
                if (isPath) {
                    ctx.strokeStyle = textColor;
                    ctx.lineWidth = 3 / scale;
                    ctx.globalAlpha = 1;
                } else {
                    ctx.strokeStyle = hovered ? (connected ? textColor : subtleColor) : subtleColor;
                    ctx.lineWidth = (connected ? 1.5 : 0.5) / scale;
                    ctx.globalAlpha = hovered ? (connected ? 0.8 : 0.1) : 0.4;
                }
                ctx.stroke();
            }
            ctx.globalAlpha = 1;

            // Community shapes
            const communityShapes = ['fill-circle', 'stroke-circle', 'dash-circle', 'fill-square', 'stroke-square', 'diamond'];

            // Draw nodes
            for (const n of nodes) {
                const isConnected = !hovered || connectedIds.has(n.id);
                const matchFilter = filter === 'all' || n.stage === filter;
                const isPathNode = pathNodeSet.has(n.id);
                ctx.globalAlpha = hovered ? (isConnected ? 1 : 0.15) : (matchFilter ? 1 : 0.05);
                if (isPathNode) ctx.globalAlpha = 1;

                const shape = n.type === 'note' ? 'fill-square' : (communityShapes[n.community % communityShapes.length] || 'fill-circle');

                if (shape === 'fill-square' || shape === 'stroke-square') {
                    const s = n.r;
                    if (shape === 'fill-square') {
                        ctx.fillStyle = textColor;
                        ctx.fillRect(n.x - s, n.y - s, s * 2, s * 2);
                    } else {
                        ctx.fillStyle = bgColor;
                        ctx.fillRect(n.x - s, n.y - s, s * 2, s * 2);
                        ctx.strokeStyle = textColor;
                        ctx.lineWidth = 2 / scale;
                        ctx.strokeRect(n.x - s, n.y - s, s * 2, s * 2);
                    }
                } else if (shape === 'diamond') {
                    ctx.beginPath();
                    ctx.moveTo(n.x, n.y - n.r);
                    ctx.lineTo(n.x + n.r, n.y);
                    ctx.lineTo(n.x, n.y + n.r);
                    ctx.lineTo(n.x - n.r, n.y);
                    ctx.closePath();
                    ctx.fillStyle = textColor;
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, n.r, 0, Math.PI * 2);
                    if (shape === 'fill-circle') {
                        ctx.fillStyle = textColor;
                        ctx.fill();
                    } else if (shape === 'stroke-circle') {
                        ctx.fillStyle = bgColor;
                        ctx.fill();
                        ctx.strokeStyle = textColor;
                        ctx.lineWidth = 2 / scale;
                        ctx.stroke();
                    } else {
                        ctx.fillStyle = bgColor;
                        ctx.fill();
                        ctx.strokeStyle = textColor;
                        ctx.lineWidth = 1 / scale;
                        ctx.setLineDash([3, 3]);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }

                // Path node: double ring
                if (isPathNode) {
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, n.r + 4, 0, Math.PI * 2);
                    ctx.strokeStyle = textColor;
                    ctx.lineWidth = 2 / scale;
                    ctx.stroke();
                }

                // Labels: show all when zoomed in, else only large/hovered
                const showLabel = scale > 1.5 || (scale > 0.8 && n.r >= 6) || n === hovered || isPathNode;
                if (isConnected && showLabel) {
                    ctx.fillStyle = textColor;
                    const fontSize = Math.max(8, 10 / scale);
                    ctx.font = (n === hovered ? 'bold ' : '') + fontSize + 'px -apple-system, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(n.label.length > 12 ? n.label.slice(0, 10) + '..' : n.label, n.x, n.y + n.r + 12 / scale);
                }
            }
            ctx.globalAlpha = 1;
            ctx.restore();
        }
    },
    watch: {
        filter() {
            if (this._ctx) this.renderGraph(this._ctx, this._W, this._H);
        }
    },
    mounted() {
        this.analytics = computeGraphAnalytics();
        this.communities = detectCommunities();
        this.$nextTick(() => this.initGraph());
    },
    beforeUnmount() {
        if (this._raf) cancelAnimationFrame(this._raf);
        const canvas = this.$refs.graphCanvas;
        if (canvas) {
            canvas.removeEventListener('wheel', this._onWheel);
            canvas.removeEventListener('mousedown', this._onMouseDown);
            canvas.removeEventListener('mousemove', this._onMouseMove);
            canvas.removeEventListener('mouseup', this._onMouseUp);
            canvas.removeEventListener('mouseleave', this._onMouseLeave);
            canvas.removeEventListener('touchstart', this._onTouchStart);
            canvas.removeEventListener('touchmove', this._onTouchMove);
            canvas.removeEventListener('touchend', this._onTouchEnd);
        }
    }
};

// 404 component
const NotFound = {
    template: `
        <div class="container">
            <div class="main" style="text-align: center;">
                <div>
                    <p style="font-size: 6rem; font-weight: 900; letter-spacing: -0.04em; line-height: 1; margin-bottom: 1rem;">404</p>
                    <p>Page not found. <router-link to="/" class="word" style="text-decoration-color: var(--border);">Go home</router-link></p>
                </div>
            </div>
            <div class="footer">
                <span>lulzx</span>
                <div class="footer-links">
                    <router-link to="/garden">garden map</router-link>
                    <a href="#" @click.prevent="wander">wander</a>
                    <a href="#" @click.prevent="toggleDark">dark/light</a>
                </div>
            </div>
        </div>
    `,
    methods: {
        wander() {
            const words = ALL_WORDS();
            const word = words[Math.floor(Math.random() * words.length)];
            this.$router.push('/words/' + word);
        },
        toggleDark() { toggleDarkMode(); }
    }
};

// Search palette component
const SearchPalette = {
    template: `
        <div class="search-overlay" v-if="isOpen" @click.self="close">
            <div class="search-modal">
                <input ref="input" class="search-input" v-model="query" @keydown="onKey" placeholder="Search words, notes, and content..." />
                <div class="search-results" v-if="results.length > 0">
                    <div v-for="(r, i) in results" :key="r.path + (r.excerpt || '')" class="search-result" :class="{ active: i === activeIndex }" @click="go(r)" @mouseenter="activeIndex = i">
                        <div style="flex:1;min-width:0;">
                            <div style="display:flex;justify-content:space-between;align-items:center;">
                                <span>{{ r.label }}</span>
                                <span class="search-result-type">{{ r.type }}</span>
                            </div>
                            <div v-if="r.excerpt" class="search-result-excerpt" v-html="r.excerpt"></div>
                        </div>
                    </div>
                </div>
                <div class="search-hint" v-else-if="query.length > 0">No results</div>
                <div class="search-hint" v-else>Type to search. Esc to close.</div>
            </div>
        </div>
    `,
    data() {
        return { isOpen: false, query: '', activeIndex: 0, pool: [], contentIndex: [] };
    },
    computed: {
        results() {
            if (!this.query) return [];
            const q = this.query.toLowerCase();
            const scored = [];
            // Title matches
            this.pool.forEach(item => {
                const name = item.label.toLowerCase();
                if (name === q) scored.push({ ...item, score: 100 });
                else if (name.startsWith(q)) scored.push({ ...item, score: 80 });
                else if (name.includes(q)) scored.push({ ...item, score: 60 });
                else {
                    let qi = 0;
                    for (let i = 0; i < name.length && qi < q.length; i++) {
                        if (name[i] === q[qi]) qi++;
                    }
                    if (qi === q.length) scored.push({ ...item, score: 30 });
                }
            });
            // Content matches
            if (q.length >= 2) {
                const addedPaths = new Set(scored.map(s => s.path));
                this.contentIndex.forEach(item => {
                    const idx = item.plaintext.indexOf(q);
                    if (idx === -1) return;
                    const start = Math.max(0, idx - 40);
                    const end = Math.min(item.plaintext.length, idx + q.length + 40);
                    let excerpt = (start > 0 ? '...' : '') + item.plaintext.slice(start, end) + (end < item.plaintext.length ? '...' : '');
                    const escaped = excerpt.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    const highlighted = escaped.replace(new RegExp(q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi'), m => '<mark>' + m + '</mark>');
                    const path = '/notes/' + item.id + '?q=' + encodeURIComponent(this.query);
                    if (!addedPaths.has('/notes/' + item.id)) {
                        scored.push({ label: item.title, path, type: 'content', excerpt: highlighted, score: 20 });
                        addedPaths.add('/notes/' + item.id);
                    }
                });
            }
            scored.sort((a, b) => b.score - a.score);
            return scored.slice(0, 12);
        }
    },
    watch: {
        query() { this.activeIndex = 0; },
        '$route'() { this.close(); }
    },
    mounted() {
        this.pool = [
            ...Object.keys(wordData).map(id => ({ label: id, path: '/words/' + id, type: 'word' })),
            ...Object.entries(notesData).map(([id, n]) => ({ label: n.title, path: '/notes/' + id, type: 'note' }))
        ];
        // Build content index for full-text search
        this.contentIndex = Object.entries(notesData).map(([id, n]) => ({
            id,
            title: n.title,
            plaintext: n.content.replace(/<[^>]*>/g, '').toLowerCase()
        }));
        window.__gardenSearch = {
            open: () => this.open(),
            close: () => this.close(),
            get isOpen() { return false; }
        };
        Object.defineProperty(window.__gardenSearch, 'isOpen', {
            get: () => this.isOpen
        });
    },
    methods: {
        open() {
            this.isOpen = true;
            this.query = '';
            this.activeIndex = 0;
            this.$nextTick(() => this.$refs.input?.focus());
        },
        close() {
            this.isOpen = false;
            this.query = '';
        },
        go(r) {
            this.$router.push(r.path);
            this.close();
        },
        onKey(e) {
            if (e.key === 'Escape') { this.close(); return; }
            if (e.key === 'ArrowDown') { e.preventDefault(); this.activeIndex = Math.min(this.activeIndex + 1, this.results.length - 1); return; }
            if (e.key === 'ArrowUp') { e.preventDefault(); this.activeIndex = Math.max(this.activeIndex - 1, 0); return; }
            if (e.key === 'Enter' && this.results[this.activeIndex]) { this.go(this.results[this.activeIndex]); return; }
        }
    }
};

// Preview card component
const PreviewCard = {
    template: `
        <div class="preview-card" v-if="visible" :style="{ top: y + 'px', left: x + 'px' }">
            <div class="preview-card-name">{{ data.name }}</div>
            <div class="preview-card-stage">{{ data.stage }}</div>
            <div class="preview-card-excerpt">{{ data.excerpt }}</div>
        </div>
    `,
    data() {
        return { visible: false, x: 0, y: 0, data: { name: '', stage: '', excerpt: '' } };
    },
    mounted() {
        this._timer = null;
        this._onMouseOver = (e) => {
            const el = e.target.closest('.chip, .inline-word-link, .word');
            if (!el) return;
            clearTimeout(this._timer);
            this._timer = setTimeout(() => {
                const href = el.getAttribute('href') || el.closest('a')?.getAttribute('href') || '';
                let info = null;
                const wordMatch = href.match(/\/words\/(.+)/);
                const noteMatch = href.match(/\/notes\/(.+)/);
                if (wordMatch && wordData[wordMatch[1]]) {
                    const w = wordData[wordMatch[1]];
                    const firstBlock = w.blocks?.[0];
                    const excerpt = firstBlock?.text || (firstBlock?.items ? firstBlock.items[0] : '') || '';
                    info = { name: wordMatch[1], stage: w.stage, excerpt: excerpt.replace(/<[^>]*>/g, '').slice(0, 100) + (excerpt.length > 100 ? '...' : '') };
                } else if (noteMatch && notesData[noteMatch[1]]) {
                    const n = notesData[noteMatch[1]];
                    const text = n.content.replace(/<[^>]*>/g, '');
                    const firstSentence = text.match(/^[^.!?]+[.!?]/)?.[0] || text.slice(0, 100);
                    info = { name: n.title, stage: n.stage, excerpt: firstSentence.slice(0, 120) };
                }
                if (!info) return;
                const rect = el.getBoundingClientRect();
                let left = rect.left;
                let top = rect.bottom + 8;
                if (left + 280 > window.innerWidth) left = window.innerWidth - 290;
                if (top + 150 > window.innerHeight) top = rect.top - 150;
                this.x = Math.max(10, left);
                this.y = top;
                this.data = info;
                this.visible = true;
            }, 200);
        };
        this._onMouseOut = (e) => {
            const el = e.target.closest('.chip, .inline-word-link, .word');
            if (el) { clearTimeout(this._timer); this.visible = false; }
        };
        this._onScroll = () => { this.visible = false; };
        document.getElementById('app').addEventListener('mouseover', this._onMouseOver);
        document.getElementById('app').addEventListener('mouseout', this._onMouseOut);
        document.getElementById('app').addEventListener('scroll', this._onScroll);
    },
    beforeUnmount() {
        const el = document.getElementById('app');
        el?.removeEventListener('mouseover', this._onMouseOver);
        el?.removeEventListener('mouseout', this._onMouseOut);
        el?.removeEventListener('scroll', this._onScroll);
    },
    watch: {
        '$route'() { this.visible = false; }
    }
};

// Timeline component
const TimelinePage = {
    template: `
        <div class="timeline-page">
            <div class="word-header">
                <router-link to="/" class="back">\u2190 back</router-link>
                <span style="font-size: 0.875rem;">lulzx</span>
            </div>
            <div class="timeline-header">
                <div class="timeline-title">Growth Timeline</div>
                <div class="timeline-subtitle">{{ totalEvents }} events across {{ monthCount }} months, from the first commit to now.</div>
            </div>
            <div class="timeline-canvas-container" ref="timelineContainer" v-scroll-reveal="{ delay: 0.1 }">
                <canvas ref="timelineCanvas"></canvas>
                <div class="timeline-tooltip" v-if="tooltipData" :style="{ top: tooltipData.y + 'px', left: tooltipData.x + 'px' }">
                    <div class="timeline-tooltip-title">{{ tooltipData.month }}</div>
                    <div v-for="item in tooltipData.items" :key="item.label" class="timeline-tooltip-item" @click="goTo(item)">{{ item.type }}: {{ item.label }}</div>
                </div>
            </div>
            <div class="garden-section">
                <div class="garden-section-title">Legend</div>
                <div style="display:flex;gap:2rem;flex-wrap:wrap;font-size:0.875rem;">
                    <span><span style="display:inline-block;width:12px;height:12px;background:var(--text);margin-right:0.5rem;vertical-align:middle;"></span>Planted</span>
                    <span><span style="display:inline-block;width:12px;height:12px;border:2px solid var(--text);margin-right:0.5rem;vertical-align:middle;"></span>Tended</span>
                </div>
            </div>
            <div class="wander-section">
                <router-link to="/garden" class="wander-btn">garden map</router-link>
                <a href="#" class="wander-btn" @click.prevent="toggleDark">dark/light</a>
                <button class="wander-btn" @click="wander">\u2192 wander to a random word</button>
            </div>
        </div>
    `,
    data() {
        return {
            tooltipData: null,
            totalEvents: 0,
            monthCount: 0,
            _bars: []
        };
    },
    methods: {
        toggleDark() { toggleDarkMode(); },
        wander() {
            const words = ALL_WORDS();
            this.$router.push('/words/' + words[Math.floor(Math.random() * words.length)]);
        },
        goTo(item) {
            if (item.route) this.$router.push(item.route);
        },
        buildData() {
            const months = new Map();
            const addEvent = (monthKey, type, label, route) => {
                if (!months.has(monthKey)) months.set(monthKey, { planted: [], tended: [] });
                const bucket = months.get(monthKey);
                if (type === 'planted') bucket.planted.push({ label, route, type: 'planted' });
                else bucket.tended.push({ label, route, type: 'tended' });
            };
            Object.entries(wordData).forEach(([id, d]) => {
                if (d.planted) addEvent(d.planted, 'planted', id, '/words/' + id);
                if (d.tended && d.tended !== d.planted) addEvent(d.tended, 'tended', id, '/words/' + id);
            });
            Object.entries(notesData).forEach(([id, n]) => {
                if (n.planted) addEvent(n.planted, 'planted', n.title, '/notes/' + id);
                if (n.tended && n.tended !== n.planted) addEvent(n.tended, 'tended', n.title, '/notes/' + id);
            });
            // Sort by date
            const sorted = [...months.entries()].sort((a, b) => a[0].localeCompare(b[0]));
            // Fill gaps
            if (sorted.length > 0) {
                const [startY, startM] = sorted[0][0].split('-').map(Number);
                const [endY, endM] = sorted[sorted.length - 1][0].split('-').map(Number);
                const all = new Map();
                let y = startY, m = startM;
                while (y < endY || (y === endY && m <= endM)) {
                    const key = y + '-' + String(m).padStart(2, '0');
                    all.set(key, months.get(key) || { planted: [], tended: [] });
                    m++;
                    if (m > 12) { m = 1; y++; }
                }
                return all;
            }
            return months;
        },
        initTimeline() {
            const canvas = this.$refs.timelineCanvas;
            const container = this.$refs.timelineContainer;
            if (!canvas || !container) return;

            const dpr = window.devicePixelRatio || 1;
            const rect = container.getBoundingClientRect();
            const W = rect.width;
            const H = rect.height;
            canvas.width = W * dpr;
            canvas.height = H * dpr;
            canvas.style.width = W + 'px';
            canvas.style.height = H + 'px';
            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);

            const data = this.buildData();
            const entries = [...data.entries()];
            this.monthCount = entries.length;

            const isMobile = W < 500;
            // Quarterly granularity on mobile
            let displayEntries;
            if (isMobile) {
                const quarters = new Map();
                entries.forEach(([key, val]) => {
                    const [y, m] = key.split('-').map(Number);
                    const q = y + '-Q' + Math.ceil(m / 3);
                    if (!quarters.has(q)) quarters.set(q, { planted: [], tended: [] });
                    const qd = quarters.get(q);
                    qd.planted.push(...val.planted);
                    qd.tended.push(...val.tended);
                });
                displayEntries = [...quarters.entries()];
            } else {
                displayEntries = entries;
            }

            let totalEvents = 0;
            displayEntries.forEach(([, v]) => { totalEvents += v.planted.length + v.tended.length; });
            this.totalEvents = totalEvents;

            const maxHeight = Math.max(...displayEntries.map(([, v]) => v.planted.length + v.tended.length), 1);
            const padding = { top: 20, bottom: 40, left: 10, right: 10 };
            const chartW = W - padding.left - padding.right;
            const chartH = H - padding.top - padding.bottom;
            const barW = Math.max(4, chartW / displayEntries.length - 2);
            const gap = (chartW - barW * displayEntries.length) / displayEntries.length;

            const styles = getComputedStyle(document.documentElement);
            const textColor = styles.getPropertyValue('--text').trim() || '#000';
            const bgColor = styles.getPropertyValue('--bg').trim() || '#fff';
            const subtleColor = styles.getPropertyValue('--gray-subtle').trim() || '#e5e5e5';

            // Animation
            const bars = [];
            displayEntries.forEach(([key, val], i) => {
                const plantedH = (val.planted.length / maxHeight) * chartH;
                const tendedH = (val.tended.length / maxHeight) * chartH;
                const x = padding.left + i * (barW + gap);
                bars.push({
                    key, x, plantedH, tendedH,
                    currentPlantedH: 0, currentTendedH: 0,
                    items: [...val.planted, ...val.tended]
                });
            });
            this._bars = bars;

            let frame = 0;
            const totalFrames = 60;
            const staggerMs = 8;

            const easeOutQuad = t => t * (2 - t);

            const animate = () => {
                ctx.clearRect(0, 0, W, H);

                // Year markers
                let lastYear = '';
                displayEntries.forEach(([key], i) => {
                    const year = key.split('-')[0];
                    if (year !== lastYear) {
                        lastYear = year;
                        const x = padding.left + i * (barW + gap);
                        ctx.beginPath();
                        ctx.setLineDash([4, 4]);
                        ctx.moveTo(x, padding.top);
                        ctx.lineTo(x, H - padding.bottom);
                        ctx.strokeStyle = subtleColor;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        ctx.setLineDash([]);
                        ctx.fillStyle = textColor;
                        ctx.font = '10px -apple-system, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(year, x + barW / 2, H - padding.bottom + 16);
                    }
                });

                // Draw bars
                bars.forEach((bar, i) => {
                    const barFrame = Math.max(0, frame - i * (staggerMs / 16));
                    const progress = easeOutQuad(Math.min(1, barFrame / totalFrames));
                    bar.currentPlantedH = bar.plantedH * progress;
                    bar.currentTendedH = bar.tendedH * progress;

                    const baseY = H - padding.bottom;
                    // Planted bar (filled)
                    if (bar.currentPlantedH > 0) {
                        ctx.fillStyle = textColor;
                        ctx.fillRect(bar.x, baseY - bar.currentPlantedH, barW, bar.currentPlantedH);
                    }
                    // Tended bar (outlined, stacked on top)
                    if (bar.currentTendedH > 0) {
                        ctx.strokeStyle = textColor;
                        ctx.lineWidth = 1.5;
                        ctx.strokeRect(bar.x, baseY - bar.currentPlantedH - bar.currentTendedH, barW, bar.currentTendedH);
                    }
                });

                frame++;
                if (frame < totalFrames + bars.length * (staggerMs / 16) + 10) {
                    this._animRaf = requestAnimationFrame(animate);
                }
            };

            this._animRaf = requestAnimationFrame(animate);
            this._ctx = ctx;
            this._W = W;
            this._H = H;

            // Hover
            canvas.addEventListener('mousemove', this._onMouseMove = (e) => {
                const r = canvas.getBoundingClientRect();
                const mx = e.clientX - r.left;
                const my = e.clientY - r.top;
                const hit = bars.find(b => mx >= b.x && mx <= b.x + barW && my >= padding.top && my <= H - padding.bottom);
                if (hit && hit.items.length > 0) {
                    this.tooltipData = {
                        x: Math.min(hit.x + barW + 10, W - 260),
                        y: Math.max(20, my - 30),
                        month: hit.key,
                        items: hit.items.slice(0, 6)
                    };
                    // Highlight column
                    if (this._ctx) {
                        animate(); // redraw
                        this._ctx.fillStyle = textColor;
                        this._ctx.globalAlpha = 0.05;
                        this._ctx.fillRect(hit.x - 2, padding.top, barW + 4, chartH);
                        this._ctx.globalAlpha = 1;
                    }
                } else {
                    this.tooltipData = null;
                }
            });
            canvas.addEventListener('mouseleave', this._onMouseLeave = () => {
                this.tooltipData = null;
            });
        }
    },
    mounted() {
        this.$nextTick(() => this.initTimeline());
    },
    beforeUnmount() {
        if (this._animRaf) cancelAnimationFrame(this._animRaf);
        const canvas = this.$refs.timelineCanvas;
        if (canvas) {
            canvas.removeEventListener('mousemove', this._onMouseMove);
            canvas.removeEventListener('mouseleave', this._onMouseLeave);
        }
    }
};

// Router
const router = createRouter({
    history: createWebHistory(),
    routes: [
        { path: '/', component: Home },
        { path: '/words/:word', component: WordPage },
        { path: '/notes/:noteId', component: NotePage },
        { path: '/garden', component: GardenMap },
        { path: '/timeline', component: TimelinePage },
        { path: '/:pathMatch(.*)*', component: NotFound }
    ],
    scrollBehavior() {
        return { top: 0 };
    }
});

// Scroll #app to top on route change (delayed to sync with transition)
router.afterEach(() => {
    setTimeout(() => { document.getElementById('app').scrollTop = 0; }, 210);
});

// Expose router for inline links
window.__gardenRouter = router;

// Dark mode
function initDarkMode() {
    if (localStorage.getItem('dark-mode') === 'true') {
        document.body.classList.add('dark');
    }
}
function toggleDarkMode() {
    document.body.classList.toggle('dark');
    localStorage.setItem('dark-mode', document.body.classList.contains('dark'));
}
initDarkMode();

// Root App component
const App = {
    template: `<div><search-palette ref="search"></search-palette><preview-card></preview-card><router-view v-slot="{ Component }"><transition name="page" mode="out-in"><component :is="Component" :key="$route.fullPath" /></transition></router-view></div>`
};

// App
const app = createApp(App);
app.component('search-palette', SearchPalette);
app.component('preview-card', PreviewCard);

// Scroll reveal directive
app.directive('scroll-reveal', {
    mounted(el, binding) {
        const delay = binding.value?.delay || 0;
        const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        if (prefersReduced) {
            el.classList.add('revealed');
            return;
        }
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    setTimeout(() => el.classList.add('revealed'), delay * 1000);
                    observer.unobserve(el);
                }
            });
        }, { threshold: 0.1 });
        observer.observe(el);
        el._scrollRevealObserver = observer;
    },
    unmounted(el) {
        el._scrollRevealObserver?.disconnect();
    }
});

app.use(router);
const vm = app.mount('#app');

// Keyboard navigation
document.addEventListener('keydown', (e) => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    if (e.key === '/' || (e.key === 'k' && (e.metaKey || e.ctrlKey))) {
        e.preventDefault();
        window.__gardenSearch?.open();
        return;
    }
    if (e.key === 'Escape') {
        if (window.__gardenSearch?.isOpen) { window.__gardenSearch.close(); return; }
        router.push('/');
        return;
    }
    if (e.key === 'w') {
        const words = ALL_WORDS();
        router.push('/words/' + words[Math.floor(Math.random() * words.length)]);
        return;
    }
    if (e.key === '[' || e.key === ']') {
        const route = router.currentRoute.value;
        if (!route.params.word) return;
        const chips = document.querySelectorAll('.connections-section .chip');
        if (chips.length === 0) return;
        const currentActive = document.querySelector('.connections-section .chip:focus');
        let idx = currentActive ? Array.from(chips).indexOf(currentActive) : -1;
        if (e.key === ']') idx = (idx + 1) % chips.length;
        else idx = (idx - 1 + chips.length) % chips.length;
        chips[idx]?.focus();
        return;
    }
});
</script>
</body>
</html>
